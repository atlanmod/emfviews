#+Title: User Guide
#+OPTIONS: ':t

* Overview
EMF Views is a tool that enables you to combine and augment several EMF-based
models in /views/.  These views behave as regular models: you can navigate,
query and transform views as you would any regular model.  This come in handy
when you want to deal with several related models.

Views can filter any element from its contributing models.  This can be used to
create views focused on a particular aspect of related models.  Filters also
enable a form of access control: one can create views that hide sensitive
information from one or more models.

Views can augment the contributing models with new attributes, associations and
classes.  This is useful for instance when combining related models: you can add
new associations that link related classes together, allowing you to navigate or
query the view more naturally.

Views can be created interactively via ~eview~ and ~eviewpoint~ definition
files, or they can be created programmatically.  EMF Views also includes two
small languages that ease the definition of views: VPDL and MEL.

* Getting Started
This section will take you through all the main features of EMF Views.

** Creating a view
We will create a view linking two related models representing books.

In order to create a view, you need the following:

1. Metamodels.  These can be given as Ecore files, or through the namespace URI
   if the packages are loaded as plugins.
2. Models.  These can be given in any serialization format supported by EMF
   (usually XMI).
3. A /viewpoint/.  This defines the metamodel of the view.  It is specified
   through an ~eviewpoint~ file.
4. An ~eview~ file which describes the view.

# TODO: expand on this unpacking

First, unpack the ~emfviews-tutorial~ example.  Here is what the file hierarchy
should look like:

#+BEGIN_EXAMPLE
.
├── metamodels
│   ├── Book.ecore
│   └── Publication.ecore
├── models
│   ├── book.xmi
│   └── publication.xmi
├── viewpoints
│   ├── publicationsAndBooks.eviewpoint
│   └── publicationsAndBooks.xmi
└── views
    ├── allChapters.ecl
    ├── allChapters.eview
    ├── firstChapter.ecl
    └── firstChapter.eview
#+END_EXAMPLE

This is one common way to organize views that are created using files, but by no
means it is mandatory.

The ~metamodels~ folder contains the Ecore files for our two metamodels, Book
and Publication.  Here are they are:

[[file:images/metamodels.png]]

The Book metamodel has details about each chapter, while the Publication has
more information about the publisher and publishing date.  This is a simple
example of two metamodels with overlapping and complementary information.  The
view we will create will bring all this information under a single (virtual)
metamodel.

The ~models~ folder contains two serialized models in XMI format that conform to
these metamodels.  Here are the contents of ~book.xmi~ (left) and
~publication.xmi~ (right):

[[file:images/models.png]]

They both model the same (fictitious) book.  In this example, there is only one
element for simplicity.  In realistic situation, each model may contain several
books or publications.  Our view will work the same with any number of elements.

To define the view, we must first define a viewpoint, which is a metamodel for
the view.  Let us look at the file hierarchy again:

#+BEGIN_EXAMPLE
├── viewpoints
│   ├── publicationsAndBooks.eviewpoint
│   └── publicationsAndBooks.xmi
#+END_EXAMPLE

The ~viewpoints~ folder contains two files.  Let us focus on the
~publicationsAndBooks.eviewpoint~ file which defines the viewpoint, and is
defined as:

#+BEGIN_EXAMPLE
contributingMetamodels=../metamodels/Publication.ecore,../metamodels/Book.ecore
weavingModel=publicationsAndBooks.xmi
#+END_EXAMPLE

The first line is a list of the /contributing metamodels/.  These are the two
metamodels we are concerned with.  In this case, we give relative URIs to the
Ecore files in the ~metamodels~ folder.

#+BEGIN_note
We could also have used namespace URIs in ~contributingModels~.  The upside of
pointing to the Ecore files in this case is that EMF Views will load them
without us having to register the EPackages manually.
#+END_note

The second line specifies the /weaving model/.  The weaving model describes how
the viewpoint is constructed: it contains filters that select or exclude
elements from the contributing metamodels, and it describes new elements that
are to be added to the viewpoint.  If you omit the ~weavingModel~ property, no
elements are filtered or added.

Let's try it now.  Remove or comment ("~#~" begins a line comment) the
~weavingModel~ line, then save the file.  You have to open the viewpoint in text
mode (Right click \to With \to Text Editor).

After you have made the change, you want to open the ~eviewpoint~ file in a
model editor.  The Sample Ecore Editor and the [[eclipse:/topic/org.eclipse.modisco.infrastructure.doc/mediawiki/model_browser/user.html][MoDisco Model Browser]] should both
be able to do so.  Right click \to Open With \to Other..., and in the dialog
select Sample Ecore Editor then click OK:

[[file:images/editor-select.png]]

Here is what you should see:

[[file:images/viewpoint-empty-weaving.png]]

This metamodel combines, under the same ~viewpoint~ package, our two metamodels
Publication and Book.  This metamodel is purely virtual: the packages
Publication and Book, and all their elements, are proxies to the actual elements
from the contributing metamodels.

Note that the ~Publication~ package comes before ~Book~ because that is the
order we specified in the ~contributingMetamodels~ line in the ~eviewpoint~ file.

Let's restore the ~weavingModel~ line.  First, close the Sample Ecore Editor view of
the ~eviewpoint~.  Then, restore or uncomment the ~weavingModel~ line in the
~eviewpoint~ by opening it with the Text Editor (or reuse the Text Editor tab if
you had not closed it).  Save the ~eviewpoint~ file, and open it up with the
Sample Ecore Editor once more.

Here is what you should get now:

[[file:images/viewpoint.png]]

There are two differences with the previous viewpoint: there is a new
~bookChapters~ association in the ~Publication~ class, and the ~Chapter.nbPages~
attribute has been filtered out.  The ~bookChapters~ association enhances the
Publication metamodel by allowing us to navigate the chapters from a
~Publication~ instance.  A ~Publication~ in this viewpoint would have all the
information of the ~Book~ instance, and more.

Note that the ~Chapter~ class is part of the ~Book~ package (it comes from the
Book metamodel), but it is the target class of an association of the
~Publication~ package.  Combining both metamodels in the viewpoint allows us to
create inter-metamodel associations, since they now are part of the same virtual
metamodel.

If we open the weaving model ~publicationsAndBooks.xmi~ with the Sample Ecore
Editor, we can see that it contains exactly these two changes.  Here is the
viewpoint on the left with the weaving model on the right.  The changes made by
the weaving model to the viewpoint are highlighted:

[[file:images/viewpoint-and-weaving.png]]

Now that we have a viewpoint, all that is left is the view itself.  Let's take
another look at the file hierarchy:

#+BEGIN_EXAMPLE
└── views
    ├── allChapters.ecl
    ├── allChapters.eview
    ├── firstChapter.ecl
    └── firstChapter.eview
#+END_EXAMPLE

In the ~views~ folder, two views are defined: ~allChapters~ and ~firstChapter~.
Let's focus on ~allChapters~ for now.  If we look inside ~allChapters.eview~:

#+BEGIN_EXAMPLE
contributingModels=../models/publication.xmi,../models/book.xmi
viewpoint=../viewpoints/publicationsAndBooks.eviewpoint
matchingModel=allChapters.ecl
#+END_EXAMPLE

The ~contributingModels~ line point to the model resources which contribute to
the view.  Note that the order of the contributing models does not have to match
the order of the ~contributingMetamodels~ line in the ~eviewpoint~ file.

The ~viewpoint~ line is a relative path to the ~eviewpoint~ file.  In order to
define a view, we need to give it a metamodel, which is a viewpoint.

Finally, the ~matchingModel~ line is a path to an Epsilon Comparison file.  The
matching model contains rules that are used by EMF Views to construct a weaving
model for the view.

#+BEGIN_note
EMF Views can be extended to use other matching models beyond ECL.  See TODO:
ADD LINK.

Instead of a matching model, you can specify a weaving model directly in the
~eview~ file.  Although the weaving model is usually too tedious to create
manually, it may be a better option when creating views programmatically.
#+END_note

Let's look at this ECL file now:

#+BEGIN_EXAMPLE
//alias_publication=http://publication
//alias_book=http://book

rule bookChapters
match p : publication!Publication
with  c : book!Chapter
{
  compare
  {
    return p.title = c.eContainer().title
       and p.author = c.eContainer().authorName;
  }
}
#+END_EXAMPLE

It describes a rule to populate the virtual association ~bookChapters~.  It
considers each publication ~p~ from the (concrete) Publication metamodel against
each chapter of the (concrete) Book metamodel; in other words, a Cartesian
product Publication \times Book.  For each pair ~(p,c)~, if the predicate in
~compare~ is true, then the matching elements are part of the association
~bookChapters~.

Here, if we have a book and a publication that refer to the same ouvrage, then
we want to add all chapters of the book to the association.  Thus, the predicate
checks that the title of the publication is the same as the book's title, and
that they both have the same author, since that is all the common information
between the two metamodels.

Note that for our two particular models which describe the same book, the
predicate will always return true.  Hence, we could have written the rule
trivially:

#+BEGIN_EXAMPLE
...
  compare
  {
    return true;
  }
}
#+END_EXAMPLE

But the former version will work with models containing more books and
publications.

When we open the ~allChapters.eview~ file with the MoDisco Model Browser (Right
click \to Open With \to Other..., and select MoDisco Model Browser then click
OK), we can see that the ~bookChapters~ associations allows us to navigate the
chapters from the Book model:

[[file:images/model-modisco.png]]

We also can see that the ~nbPages~ attribute is absent from the chapters,
because it was filtered out from the metamodel.

Now, we have defined a view that combines the Book and Publication models.  But
we can define multiple views for the same viewpoint.  Take a look at
~firstChapter.eview~:

#+BEGIN_EXAMPLE
contributingModels=../models/publication.xmi,../models/book.xmi
viewpoint=../viewpoints/publicationsAndBooks.eviewpoint
matchingModel=firstChapter.ecl
#+END_EXAMPLE

The only difference with ~allChapters.eview~ is the matching model.  For this
view, we want only the /first/ chapter of a matching book to be added to the new
~bookChapters~ association.  Consequently, in ~firstChapter.ecl~, the predicate
is:

#+BEGIN_EXAMPLE
return p.title = c.eContainer().title
   and c = c.eContainer().eContents().first();
#+END_EXAMPLE

The right-hand part of the condition only matches if the chapter ~c~ is the
first one of the book it is part of.

As a result, when we open ~firstChapter.eview~ with the MoDisco Model Browser,
only one chapter is part of the ~bookChapters~ association:

[[file:images/view-first-chapter.png]]

And that's it!  We have created one viewpoint combining two metamodels, then we
created two views combining two models using the same viewpoint.  Note that
while this method of creating views with ~eviewpoint~ and ~eview~ files is
adequate for creating small-scale views interactively, EMF Views lets you create
views with two other methods: programmatically and using VPDL.

In the next two sections, we will show how we can filter other elements in the
viewpoint, and how we can add new virtual elements.

** Filtering elements

# by editing the weaving model
# Filter some classes, bam we don't see them in the view

** Adding new associations

# show we can navigate between the two models with the new links

** Querying a view with OCL

# show that it works

** Transforming a view with ATL

# idem

* Reference
** Glossary
- View ::
- Viewpoint ::
- Weaving model ::
- Virtual element ::
- Contributing model ::

* Creating views
There are three ways to create views:

1. By writing an ~eview~ file.
2. By writing a VPDL file.
3. By using the EMF Views API programmatically.

The ~VPDL~ method is the fastest for interactive creation, although the ~eview~ approach
is more flexible.  Using the API should be preferred when creating views from
Java code.

** In Eclipse
You need two


** Programmatically
Create a ~new View~ after creating a ~new Viewpoint~.

#+BEGIN_EXAMPLE
Viewpoint viewpoint = new Viewpoint(Arrays.asList(myPackage), emptyWeavingModel);
View view = new View(viewpoint, Arrays.asList(myModel), emptyWeavingModel);
#+END_EXAMPLE

You can browse the contents of the viewpoint or view directly.

You also associate them to a resource:

#+BEGIN_SRC java
ViewpointResource viewpointResource = new ViewpointResource("resourceURI...");
viewpointResource.setViewpoint(viewpoint);

ViewResource viewResource = new ViewResource("myview.eview");
viewResource.setView(view);
viewResource.save(null);
#+END_SRC

This will save the view to the ~myview.eview~ file.

** Using a DSL
Use VPDL to create views and viewpoints.

#+BEGIN_SRC vpdl
create view full as

select v.ConcreteElement[model, path],
       v.ConcreteConcept join ecore.EClass as eClass,

from 'http://www.atlanmod.org/emfviews/virtuallinks/0.3.0' as v,
     'http://www.eclipse.org/emf/2002/Ecore' as ecore,
#+END_SRC

* Creating weaving models
Weaving models describe what elements are put into viewpoints and views.

Weaving models contain filters.

** How to create weaving models
By editing an XMI file.

By using the EMF-generated API.

By using DSLs such as VPDL and MEL which can generate eviewpoint files with
accompanying weaving models.
