#+Title: EMF Views User Guide
#+OPTIONS: ':t

* Overview and Getting Started
EMF Views is a tool that enables you to combine and augment several EMF-based
models in /views/.  These views behave as regular models: you can navigate,
query and transform views as you would any regular model.  This come in handy
when you want to deal with several related models.

Views can filter any element from its contributing models.  This can be used to
create views focused on a particular aspect of related models.  Filters also
enable a form of access control: one can create views that hide sensitive
information from one or more models.

Views can augment the contributing models with new attributes, associations and
classes.  This is useful for instance when combining related models: you can add
new associations that link related classes together, allowing you to navigate or
query the view more naturally.

Views can be created interactively via ~eview~ and ~eviewpoint~ definition
files, or they can be created programmatically.  EMF Views also includes two
small languages that ease the definition of views: VPDL and MEL.

*** Getting Started
[[*Creating a view manually][Creating a view manually]] will section will take you through the main features of
EMF Views.

* User Guide
** Views
There are three ways to create views:

1. By writing an ~eview~ file.
2. By writing a VPDL file.
3. By using the EMF Views API programmatically.

The ~VPDL~ method is the fastest for interactive creation, although the ~eview~
approach is more flexible.  Using the API should be preferred when creating
views from Java code.

*** In Eclipse
You need two

*** Programmatically
Create a ~new View~ after creating a ~new Viewpoint~.

#+BEGIN_SRC
Viewpoint viewpoint = new Viewpoint(Arrays.asList(myPackage), emptyWeavingModel);
View view = new View(viewpoint, Arrays.asList(myModel), emptyWeavingModel);
#+END_SRC

You can browse the contents of the viewpoint or view directly.

You also associate them to a resource:

#+BEGIN_SRC java
ViewpointResource viewpointResource = new ViewpointResource("resourceURI...");
viewpointResource.setViewpoint(viewpoint);

ViewResource viewResource = new ViewResource("myview.eview");
viewResource.setView(view);
viewResource.save(null);
#+END_SRC

This will save the view to the ~myview.eview~ file.

*** Using a DSL
Use VPDL to create views and viewpoints.

#+BEGIN_SRC vpdl
create view full as

select v.ConcreteElement[model, path],
       v.ConcreteConcept join ecore.EClass as eClass,

from 'http://www.atlanmod.org/emfviews/virtuallinks/0.3.0' as v,
     'http://www.eclipse.org/emf/2002/Ecore' as ecore,
#+END_SRC

* Weaving models
Weaving models describe what elements are put into viewpoints and views.

Weaving models contain filters.

** How to create weaving models
By editing an XMI file.

By using the EMF-generated API.

By using DSLs such as VPDL and MEL which can generate eviewpoint files with
accompanying weaving models.

** Filtering elements

# by editing the weaving model
# Filter some classes, bam we don't see them in the view

** Adding new associations

# show we can navigate between the two models with the new links

** VPDL
# Give a tour of the syntax, couple of showcases

** MEL
# tour of syntax, couple of showcases

* Tutorials
** Creating a view manually
We will create a view linking two related models representing books.

In order to create a view, you need the following:

1. Metamodels.  These can be given as Ecore files, or through the namespace URI
   if the packages are loaded as plugins.
2. Models.  These can be given in any serialization format supported by EMF
   (usually XMI).
3. A /viewpoint/.  This defines the metamodel of the view.  It is specified
   through an ~eviewpoint~ file.
4. An ~eview~ file which describes the view.

# TODO: expand on this unpacking

First, unpack the ~emfviews-tutorial~ example.  Here is what the file hierarchy
should look like:

#+BEGIN_EXAMPLE
.
├── metamodels
│   ├── Book.ecore
│   └── Publication.ecore
├── models
│   ├── book.xmi
│   └── publication.xmi
├── viewpoints
│   ├── publicationsAndBooks.eviewpoint
│   └── publicationsAndBooks.xmi
└── views
    ├── allChapters.ecl
    ├── allChapters.eview
    ├── firstChapter.ecl
    └── firstChapter.eview
#+END_EXAMPLE

This is one common way to organize views that are created using files, but by no
means it is mandatory.

The ~metamodels~ folder contains the Ecore files for our two metamodels, Book
and Publication.  Here are they are:

[[file:images/metamodels.png]]

The Book metamodel has details about each chapter, while the Publication has
more information about the publisher and publishing date.  This is a simple
example of two metamodels with overlapping and complementary information.  The
view we will create will bring all this information under a single (virtual)
metamodel.

The ~models~ folder contains two serialized models in XMI format that conform to
these metamodels.  Here are the contents of ~book.xmi~ (left) and
~publication.xmi~ (right):

[[file:images/models.png]]

They both model the same (fictitious) book.  In this example, there is only one
element for simplicity.  In realistic situation, each model may contain several
books or publications.  Our view will work the same with any number of elements.

To define the view, we must first define a viewpoint, which is a metamodel for
the view.  Let us look at the file hierarchy again:

#+BEGIN_EXAMPLE
├── viewpoints
│   ├── publicationsAndBooks.eviewpoint
│   └── publicationsAndBooks.xmi
#+END_EXAMPLE

The ~viewpoints~ folder contains two files.  Let us focus on the
~publicationsAndBooks.eviewpoint~ file which defines the viewpoint, and is
defined as:

#+BEGIN_SRC
contributingMetamodels=../metamodels/Publication.ecore,\
                       ../metamodels/Book.ecore
weavingModel=publicationsAndBooks.xmi
#+END_SRC

The first two lines list the /contributing metamodels/.  These are the two
metamodels we are concerned with.  In this case, we give relative URIs to the
Ecore files in the ~metamodels~ folder.

#+BEGIN_note
We could also have used namespace URIs in ~contributingModels~.  The upside of
pointing to the Ecore files in this case is that EMF Views will load them
without us having to register the EPackages manually.
#+END_note

The third line specifies the /weaving model/.  The weaving model describes how
the viewpoint is constructed: it contains filters that select or exclude
elements from the contributing metamodels, and it describes new elements that
are to be added to the viewpoint.  If you omit the ~weavingModel~ property, no
elements are filtered or added.

Let's try it now.  Remove or comment (~#~ begins a line comment) the
~weavingModel~ line, then save the file.  You have to open the viewpoint in text
mode (Right click \to ~Open With~ \to ~Text Editor~).

After you have made the change, you want to open the ~eviewpoint~ file in a
model editor.  The Sample Ecore Model Editor and the [[eclipse:/topic/org.eclipse.modisco.infrastructure.doc/mediawiki/model_browser/user.html][MoDisco Model Browser]]
should both be able to do so.  Right click \to ~Open With~ \to ~Other...~, and
in the dialog select ~Sample Ecore Model Editor~ then click OK:

[[file:images/editor-select.png]]

Here is what you should see:

[[file:images/viewpoint-empty-weaving.png]]

This metamodel combines, under the same ~viewpoint~ package, our two metamodels
Publication and Book.  This metamodel is purely virtual: the packages
Publication and Book, and all their elements, are proxies to the actual elements
from the contributing metamodels.

Note that the ~Publication~ package comes before ~Book~ because that is the
order we specified in the ~contributingMetamodels~ line in the ~eviewpoint~ file.

Let's restore the ~weavingModel~ line.  First, close the Sample Ecore Model
Editor view of the ~eviewpoint~.  Then, restore or uncomment the ~weavingModel~
line in the ~eviewpoint~ by opening it with the Text Editor (or reuse the Text
Editor tab if you had not closed it).  Save the ~eviewpoint~ file, and open it
up with the Sample Ecore Model Editor once more.

Here is what you should get now:

[[file:images/viewpoint.png]]

There are two differences with the previous viewpoint: there is a new
~bookChapters~ association in the ~Publication~ class, and the ~Chapter.nbPages~
attribute has been filtered out.  The ~bookChapters~ association enhances the
Publication metamodel by allowing us to navigate the chapters from a
~Publication~ instance.  A ~Publication~ in this viewpoint would have all the
information of the ~Book~ instance, and more.

Note that the ~Chapter~ class is part of the ~Book~ package (it comes from the
Book metamodel), but it is the target class of an association of the
~Publication~ package.  Combining both metamodels in the viewpoint allows us to
create inter-metamodel associations, since they now are part of the same virtual
metamodel.

If we open the weaving model ~publicationsAndBooks.xmi~ with the Sample Ecore
Model Editor, we can see that it contains exactly these two changes.  Here is
the viewpoint on the left with the weaving model on the right.  The changes made
by the weaving model to the viewpoint are highlighted:

[[file:images/viewpoint-and-weaving.png]]

Now that we have a viewpoint, all that is left is the view itself.  Let's take
another look at the file hierarchy:

#+BEGIN_EXAMPLE
└── views
    ├── allChapters.ecl
    ├── allChapters.eview
    ├── firstChapter.ecl
    └── firstChapter.eview
#+END_EXAMPLE

In the ~views~ folder, two views are defined: ~allChapters~ and ~firstChapter~.
Let's focus on ~allChapters~ for now.  If we look inside ~allChapters.eview~:

#+BEGIN_SRC
contributingModels=../models/publication.xmi,../models/book.xmi
viewpoint=../viewpoints/publicationsAndBooks.eviewpoint
matchingModel=allChapters.ecl
#+END_SRC

The ~contributingModels~ line point to the model resources which contribute to
the view.  Note that the order of the contributing models does not have to match
the order of the ~contributingMetamodels~ line in the ~eviewpoint~ file.

The ~viewpoint~ line is a relative path to the ~eviewpoint~ file.  In order to
define a view, we need to give it a metamodel, which is a viewpoint.

Finally, the ~matchingModel~ line is a path to an Epsilon Comparison file.  The
matching model contains rules that are used by EMF Views to construct a weaving
model for the view.

#+BEGIN_note
EMF Views can be extended to use other matching models beyond ECL.  See [[file:developer.org::*Adding%20matching%20models][Adding
matching models]].

Instead of a matching model, you can specify a weaving model directly in the
~eview~ file.  Although the weaving model is usually too tedious to create
manually, it may be a better option when creating views programmatically.
#+END_note

Let's look at this ECL file now:

#+BEGIN_SRC
//alias_publication=http://publication
//alias_book=http://book

rule bookChapters
match p : publication!Publication
with  c : book!Chapter
{
  compare
  {
    return p.title = c.eContainer().title
       and p.author = c.eContainer().authorName;
  }
}
#+END_SRC

It describes a rule to populate the virtual association ~bookChapters~.  It
considers each publication ~p~ from the (concrete) Publication metamodel against
each chapter of the (concrete) Book metamodel; in other words, a Cartesian
product Publication \times Book.  For each pair ~(p,c)~, if the predicate in
~compare~ is true, then the matching elements are part of the association
~bookChapters~.

Here, if we have a book and a publication that refer to the same ouvrage, then
we want to add all chapters of the book to the association.  Thus, the predicate
checks that the title of the publication is the same as the book's title, and
that they both have the same author, since that is all the common information
between the two metamodels.

Note that for our two particular models which describe the same book, the
predicate will always return true.  Hence, we could have written the rule
trivially:

#+BEGIN_SRC
...
  compare
  {
    return true;
  }
}
#+END_SRC

But the former version will work with models containing more books and
publications.

When we open the ~allChapters.eview~ file with the MoDisco Model Browser (Right
click \to ~Open With~ \to ~Other...~, and select MoDisco Model Browser then
click OK), we can see that the ~bookChapters~ associations allows us to navigate
the chapters from the Book model:

[[file:images/model-modisco.png]]

We also can see that the ~nbPages~ attribute is absent from the chapters,
because it was filtered out from the metamodel.

Now, we have defined a view that combines the Book and Publication models.  But
we can define multiple views for the same viewpoint.  Take a look at
~firstChapter.eview~:

#+BEGIN_SRC
contributingModels=../models/publication.xmi,../models/book.xmi
viewpoint=../viewpoints/publicationsAndBooks.eviewpoint
matchingModel=firstChapter.ecl
#+END_SRC

The only difference with ~allChapters.eview~ is the matching model.  For this
view, we want only the /first/ chapter of a matching book to be added to the new
~bookChapters~ association.  Consequently, in ~firstChapter.ecl~, the predicate
is:

#+NAME: first-chapter-predicate
#+BEGIN_SRC
return p.title = c.eContainer().title
   and c = c.eContainer().eContents().first();
#+END_SRC

The right-hand part of the condition only matches if the chapter ~c~ is the
first one of the book it is part of.

As a result, when we open ~firstChapter.eview~ with the MoDisco Model Browser,
only one chapter is part of the ~bookChapters~ association:

#+name: first-chapter-view
[[file:images/view-first-chapter.png]]

And that's it!  We have created one viewpoint combining two metamodels, then we
created two views combining two models using the same viewpoint.  Note that
while this method of creating views with ~eviewpoint~ and ~eview~ files is
adequate for creating small-scale views interactively, EMF Views offers two
other methods to create views: programmatically and using VPDL.

In the next two sections, we will show how we can filter other elements in the
viewpoint, and how we can add new virtual elements.

** Creating a view with VPDL
*** The VPDL syntax
VPDL, standing for /ViewPoint Description Language/, is a domain-specific
language for easing the creation of views and viewpoints when using EMF Views.
The syntax of VPDL is inspired by SQL's ~SELECT~ statement.

#+BEGIN_note
The VPDL syntax is still experimental and likely to change in the near future.
#+END_note

Instead of manually creating ~eviewpoint~ and ~eview~ files, you write a single
~vpdl~ file which describes the viewpoint and the view at the same time.  Here
is a VPDL file recreating the ~firstChapter~ view of the previous section:

#+BEGIN_SRC sql
create view publicationsAndBooks as

select pub.Publication.*,
       pub.Publication join book.Chapter as firstChapter,
       book.Book.*,
       book.Chapter.title,

from 'http://publication' as pub,
     'http://book' as book,

where 's.title = t.eContainer().title
   and t = t.eContainer().eContents().first()'
      for firstChapter
#+END_SRC

The first line ~create view~ specifies the name of the viewpoint.  This name is
used for generating the ~eviewpoint~, ~eview~ and ~xmi~ weaving model file.

With the ~select~ clause, you explicitly select the classes and features from
the contributing metamodels that will appear in the viewpoint.  The ~select~
clauses essentially specifies the viewpoint's weaving model, albeit in plain
text.  Here with ~pub.Publication.*~ we say that we want all features of the
~pub.Publication~ class in the viewpoint, and by selecting only
~book.Chapter.title~ from ~book.Chapter~, we exclude the ~nbPages~ attribute.
The ~select~ clause is a whitelist, so if we don't include the ~book.Book.*~
line for instance, the resulting viewpoint would not let us navigate ~Book~
instances, since there would be no visible features.

The line:

#+BEGIN_SRC sql
       pub.Publication join book.Chapter as firstChapter,
#+END_SRC

tells EMF Views to create a virtual association from ~Publication~ to ~Chapter~
called ~firstChapter~.  This is the same as the ~bookChapter~ association of the
previous section.

The ~from~ clause simply maps the namespace URIs of the contributing metamodels
to aliases used in the ~select~ clause.

Lastly, the ~where~ clause specifies, for each new association, how to match
elements from contributing models.  This is used to generate the matching model
as an ECL file.  Here, we use the same predicate as [[first-chapter-predicate][before]], but this time ~s~
and ~t~ refer respectively to the source (~Publication~) and target (~Chapter~)
of the association.

*** Using a VPDL file in Eclipse
To use a VPDL file, your project need to be configured as an Xtext project in
Eclipse.  If you create a new project and add a ~vpdl~ file in it, Eclipse
should prompt you to configure it as an Xtext project.  Otherwise in the
outline, Right click on the project \to ~Configure~ \to ~Convert to Xtext
project~.

Once the project is configured, whenever you save the ~vpdl~ file Xtext should
generate three files: the ~eviewpoint~, the ~xmi~ weaving model, and the ~ecl~
matching model.

If you unpack the ~vpdl-tutorial~ example, here is what the file hierarchy looks
like after we save the ~publicationAndBooks.vpdl~ file:

#+BEGIN_EXAMPLE
.
├── src
│   └── publicationsAndBooks.vpdl
├── src-gen
│   ├── publicationsAndBooks.ecl
│   ├── publicationsAndBooks.eviewpoint
│   └── publicationsAndBooks.xmi
└── views
    └── firstChapter.eview
#+END_EXAMPLE

All the generated files are in the ~src-gen~ directory.

To create the view however, we still need an ~eview~ file.  VPDL does not create
one for view (yet).  You just have to point to the generated files, and specify
the contributing models you want to use.  Here is the definition of
~firstChapter.eview~:

#+BEGIN_SRC
viewpoint=../src-gen/publicationsAndBooks.eviewpoint
contributingModels=../../emfviews-tutorial/models/publication.xmi,\
                   ../../emfviews-tutorial/models/book.xmi
matchingModel=../src-gen/publicationsAndBooks.ecl
weavingModel=publicationAndBooks.xmi
#+END_SRC

Opening ~firstChapter.eview~ using the MoDisco Model Browser, we get the same
result as [[first-chapter-view][before]], the difference being that this time the new association is
more accurately called ~firstChapter~:

[[file:images/vpdl-view-first-chapter.png]]

** Querying a view with OCL

# show that it works

** Transforming a view with ATL

# idem

* Glossary
- ECL :: Epsilon Comparison Language
- OCL :: Object Query Language
- ATL :: Atlanmod Transformation Language
- Viewpoint ::
- Weaving model ::
- Virtual element ::
- Contributing model ::
