-- @atlcompiler emftvm
-- @path MEL=/fr.inria.atlanmod.emfviews.mel/model/generated/Mel.ecore
-- @path VirtualLinks=/fr.inria.atlanmod.emfviews.virtuallinks/resource/VirtualLinks.ecore
-- @nsURI ECORE=http://www.eclipse.org/emf/2002/Ecore

module MEL2VirtualLinks;
create OUT : VirtualLinks from IN : MEL;

rule Model2VirtualLinks {
  from s : MEL!Model
  to   t : VirtualLinks!WeavingModel (
      name <- s.extensionName,
      whitelist <- false,
      contributingModels <- s.imports,
      virtualLinks <- Bag{
          MEL!AddClass.allInstances(),
          MEL!AddAttribute.allInstances(),
          MEL!AddReference.allInstances(),
          MEL!FilterClass.allInstances(),
	      MEL!FilterProperty.allInstances()
	      		->collect(e | thisModule.FilterProperty(e.property,
	      		                                        e.refImmediateComposite().class)),

    	  -- Desugaring modify property into filter + add
	      MEL!ModifyAttribute.allInstances()
	            ->collect(e | Bag{thisModule.ModifyAttribute(e),
	      		                  thisModule.FilterProperty(e.property,
	      		                                            e.refImmediateComposite().class)})
	      		->flatten(),
		  MEL!ModifyReference.allInstances()
	            ->collect(e | Bag{thisModule.ModifyReference(e),
	      		                  thisModule.FilterProperty(e.property,
	      		                                            e.refImmediateComposite().class)})
                ->flatten()
      }->flatten()
	)
}

rule Metamodel {
    from s : MEL!Metamodel
    to   t : VirtualLinks!ContributingModel (
        URI <- s.nsURI
    )
}

rule AddClass {
    from s : MEL!AddClass
    to   t : VirtualLinks!VirtualConcept (
        name <- s.name,
        superConcepts <- s.parents->collect(e | e.toLink()),
        subConcepts <- s.children->collect(e | e.toLink())
    )
}

rule FilterClass {
    from s : MEL!FilterClass
    to   t : VirtualLinks!Filter (
        name <- s.class.metamodel.name + '.' + s.class.class.name,
        target <- s.class.toLink()
    )
}

rule AddAttribute {
    from s : MEL!AddAttribute
    to  
    t : VirtualLinks!VirtualProperty (
        name <- s.name,
        type <- s.type,
        parent <- s.refImmediateComposite().class.toLink(),
        optional <- s.isOptional()
    )
}

unique lazy rule ModifyAttribute {
    from s : MEL!ModifyAttribute
    to   t : VirtualLinks!VirtualProperty (
        name <- if s.newName.oclIsUndefined()
        		then s.property.name
        		else s.newName
        		endif,
        type <- if s.type.oclIsUndefined()
        		then s.property.eType.name
        		else s.type
        		endif,
        parent <- s.refImmediateComposite().class.toLink(),
        optional <- false -- TODO
    )
}

rule AddReference {
    from s : MEL!AddReference
    to  
    t : VirtualLinks!VirtualAssociation (
        name <- s.name,
        source <- s.refImmediateComposite().class.toLink(),
        target <- s.type.toLink(),
        lowerBound <- s.cardinality.lowerBound.toInt(),
        upperBound <- s.cardinality.upperBound.toInt(),
        composition <- s.relationType = #composition
    )
}

unique lazy rule ModifyReference {
    from s : MEL!ModifyReference
    using {
        target : MEL!ConcreteClass = s.refImmediateComposite().class;
    }
    to   t : VirtualLinks!VirtualAssociation (
        name <- if s.newName.oclIsUndefined()
        		then s.property.name
        		else s.newName
        		endif,
        source <- s.refImmediateComposite().class.toLink(),
        target <- if s.type.oclIsUndefined()
				  then s.property.eType.toLink()
				  -- s.type must be a TargetClass for a reference
        		  else s.type.toLink()
        		  endif,
		lowerBound <- 0, -- TODO
		upperBound <- 1, -- TODO
		composition <- false -- TODO
    )
}

unique lazy rule FilterProperty {
    from property : ECORE!EStructuralFeature, target: MEL!ConcreteClass
    to   t : VirtualLinks!Filter (
        name <- target.metamodel.name + '.' + target.class.name + '.' + property.name,
        -- We assume we can't filter properties of virtual classes
        target <- thisModule.ConcreteElement(target.metamodel, target.class, property)
    )
}

unique lazy rule ConcreteElement {
    from m: MEL!Metamodel, class: ECORE!EClass, feature: ECORE!EStructuralFeature
    to   t : VirtualLinks!ConcreteElement (
        model <- m,
        path <- class.name + '.' + feature.name
    )
}

helper context MEL!VirtualClass def : toLink() : VirtualLinks!Concept =
    self.class
;

helper context MEL!ConcreteClass def : toLink() : VirtualLinks!Concept =
	thisModule.ConcreteConcept(self.metamodel, self.class)
;

helper context ECORE!EClass def : toLink() : VirtualLinks!Concept =
    thisModule.ConcreteConcept(MEL!Metamodel.allInstances()->select(e | e.nsURI = self.ePackage.nsURI).first(),
                               self)
;

unique lazy rule ConcreteConcept {
	from m : MEL!Metamodel, c: ECORE!EClass
	to   t : VirtualLinks!ConcreteConcept (
    	model <- m,
    	path <- c.name
  	)
}

helper context MEL!CardinalityBound def : toInt() : ECORE!EInt =
    if      self = #"0" then  0
    else if self = #"1" then  1
         else                -1  -- '*' case
         endif
    endif
;

-- Attributes are non-optional by default
helper context MEL!AddAttribute def : isOptional() : ECORE!EBoolean =
    if self.cardinality.oclIsUndefined() then false
    else self.cardinality.lowerBound = #"0"
    endif
;
