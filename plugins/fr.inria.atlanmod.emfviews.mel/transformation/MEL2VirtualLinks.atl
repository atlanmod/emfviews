-- @atlcompiler emftvm
-- @path MEL=/fr.inria.atlanmod.emfviews.mel/model/generated/Mel.ecore
-- @path VirtualLinks=/fr.inria.atlanmod.emfviews.virtuallinks/resource/VirtualLinks.ecore
-- @nsURI ECORE=http://www.eclipse.org/emf/2002/Ecore

module MEL2VirtualLinks;
create OUT : VirtualLinks from IN : MEL;

rule Model2VirtualLinks {
  from s : MEL!Model
  to   t : VirtualLinks!WeavingModel (
      name <- s.extensionName,
      whitelist <- false,
      contributingModels <- s.imports,
      virtualLinks <- Bag{
          MEL!AddClass.allInstances(),
          MEL!AddAttribute.allInstances(),
          MEL!AddReference.allInstances(),
          MEL!FilterClass.allInstances(),
	      MEL!FilterProperty.allInstances()
      }->flatten()
	)
}

rule Metamodel {
    from s : MEL!Metamodel
    to   t : VirtualLinks!ContributingModel (
        URI <- s.nsURI
    )
}

rule AddClass {
    from s : MEL!AddClass
    to   t : VirtualLinks!VirtualConcept (
        name <- s.name,
        superConcepts <- s.parents->collect(e | e.toLink()),
        subConcepts <- s.children->collect(e | e.toLink())
    )
}

rule FilterClass {
    from s : MEL!FilterClass
    to   t : VirtualLinks!Filter (
        name <- s.class.metamodel.name + '.' + s.class.class.name,
        target <- s.class.toLink()
    )
}

rule AddAttribute {
    from s : MEL!AddAttribute
    to  
    t : VirtualLinks!VirtualProperty (
        name <- s.name,
        type <- s.type.name,
        parent <- s.refImmediateComposite().class.toLink(),
        optional <- s.isOptional()
    )
}

rule AddReference {
    from s : MEL!AddReference
    to  
    t : VirtualLinks!VirtualAssociation (
        name <- s.name,
        source <- s.refImmediateComposite().class.toLink(),
        target <- s.type.toLink(),
        lowerBound <- s.cardinality.lowerBound.toInt(),
        upperBound <- s.cardinality.upperBound.toInt(),
        composition <- s.relationType = #composition
    )
}

rule FilterProperty {
    from s : MEL!FilterProperty
    using {
        target : MEL!ConcreteClass = s.refImmediateComposite().class;
    }
    to   t : VirtualLinks!Filter (
        name <- target.metamodel.name + '.' + target.class.name + '.' + s.property.name,
        -- We assume we can't filter properties of virtual classes
        target <- thisModule.ConcreteElement(target.metamodel, target.class, s.property)
    )
}

unique lazy rule ConcreteElement {
    from m: MEL!Metamodel, class: ECORE!EClass, feature: ECORE!EStructuralFeature
    to   t : VirtualLinks!ConcreteElement (
        model <- m,
        path <- class.name + '.' + feature.name
    )
}

helper context MEL!VirtualClass def : toLink() : VirtualLinks!Concept =
    self.class
;

helper context MEL!ConcreteClass def : toLink() : VirtualLinks!Concept =
	thisModule.ConcreteConcept(self.metamodel, self.class)
;

unique lazy rule ConcreteConcept {
	from m : MEL!Metamodel, c: ECORE!EClass
	to   t : VirtualLinks!ConcreteConcept (
    	model <- m,
    	path <- c.name
  	)
}

helper context MEL!CardinalityBound def : toInt() : ECORE!EInt =
    if      self = #"0" then  0
    else if self = #"1" then  1
         else                -1  -- '*' case
         endif
    endif
;

-- Attributes are non-optional by default
helper context MEL!AddAttribute def : isOptional() : ECORE!EBoolean =
    if self.cardinality.oclIsUndefined() then false
    else self.cardinality.lowerBound = #"0"
    endif
;
