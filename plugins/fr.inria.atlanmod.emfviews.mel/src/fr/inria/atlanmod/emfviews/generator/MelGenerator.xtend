/*
 * generated by Xtext 2.12.0
 */
package fr.inria.atlanmod.emfviews.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import fr.inria.atlanmod.emfviews.mel.Model
import org.eclipse.m2m.atl.emftvm.EmftvmFactory
import org.eclipse.emf.ecore.resource.impl.ResourceSetImpl
import org.eclipse.m2m.atl.emftvm.util.DefaultModuleResolver
import org.eclipse.emf.common.util.URI
import org.eclipse.m2m.atl.emftvm.util.TimingData
import java.io.ByteArrayOutputStream
import fr.inria.atlanmod.emfviews.mel.Metamodel

/*
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class MelGenerator extends AbstractGenerator {
  
  def String extensionName(Resource r) {
    r.allContents.toIterable().filter(Model).<Model>head.extensionName
  }
  
  def Iterable<Metamodel> getAllMetamodels(Resource r) {
    r.allContents.toIterable().filter(Metamodel)
  }

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
	  val name = extensionName(resource)
	  
    fsa.generateFile(name + '.eviewpoint', resource.compileEviewpoint(fsa))	  
	  fsa.generateFile(name + '.xmi', resource.compileXMI)
	}

  def compileEviewpoint(Resource r, IFileSystemAccess2 fsa) '''
    contributingMetamodels=«r.getAllMetamodels.map([m | m.nsURI]).join(',')»
    weavingModel=«extensionName(r)».xmi
  ''' 	
	
	def compileXMI(Resource r) {
	  // @Refactor: lifted from VpdlGenerator.xtend 
	  var factory = EmftvmFactory.eINSTANCE
    var rs = new ResourceSetImpl()
    
    var env = factory.createExecEnv();
    
    // Load metamodels
    var sourceMM = factory.createMetamodel()
    sourceMM.resource = rs.getResource(URI.createURI("http://www.inria.fr/atlanmod/emfviews/mel"), true)
    env.registerMetaModel("MEL", sourceMM)
    
    var targetMM = factory.createMetamodel()
    targetMM.resource = rs.getResource(URI.createURI("http://inria.fr/virtualLinks"), true)
    env.registerMetaModel("VirtualLinks", targetMM)
    
    // Load models
    var sourceModel = factory.createModel()
    sourceModel.resource = r
    env.registerInputModel("IN", sourceModel)
    
    var targetModel = factory.createModel()
    // The URI does not actually matter here, as we save the resource to a String
    targetModel.resource = rs.createResource(URI.createFileURI("foo.xmi"))
    env.registerOutputModel("OUT", targetModel)
    
    // Run the transformation
    var mr = new DefaultModuleResolver("platform:/plugin/fr.inria.atlanmod.emfviews.mel/transformation/",
      new ResourceSetImpl())
    
    var timing = new TimingData()
    env.loadModule(mr, "MEL2VirtualLinks")
    timing.finishLoading    
    env.run(timing)
    timing.finish
    
    // Write to a String and return
    var out = new ByteArrayOutputStream()
    targetModel.resource.save(out, null)
    
    return new String(out.toByteArray())
	}
}
