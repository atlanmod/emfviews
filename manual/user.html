<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>EMF Views User Guide</title>
<meta name="generator" content="Org mode">
<meta name="author" content="root">
<link rel="stylesheet" href="style.css">
<script src="scroll.js"></script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2018 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<header><h1 class="title">EMF Views User Guide</h1>
  <a href="/emfviews" class="btn"><svg aria-hidden="true" class="icon" viewBox="0 0 1792 1792" xmlns="http://www.w3.org/2000/svg"><path d="M1472 992v480q0 26-19 45t-45 19h-384v-384h-256v384h-384q-26 0-45-19t-19-45v-480q0-1 .5-3t.5-3l575-474 575 474q1 2 1 6zm223-69l-62 74q-8 9-21 11h-3q-13 0-21-7l-692-577-692 577q-12 8-24 7-13-2-21-11l-62-74q-8-10-7-23.5t11-21.5l719-599q32-26 76-26t76 26l244 204v-195q0-14 9-23t23-9h192q14 0 23 9t9 23v408l219 182q10 8 11 21.5t-7 23.5z"/></svg>Home</a>
  <a href="index.html" class="btn"><svg aria-hidden="true" class="icon" viewBox="0 0 1792 1792" xmlns="http://www.w3.org/2000/svg"><path d="M1703 478q40 57 18 129l-275 906q-19 64-76.5 107.5t-122.5 43.5h-923q-77 0-148.5-53.5t-99.5-131.5q-24-67-2-127 0-4 3-27t4-37q1-8-3-21.5t-3-19.5q2-11 8-21t16.5-23.5 16.5-23.5q23-38 45-91.5t30-91.5q3-10 .5-30t-.5-28q3-11 17-28t17-23q21-36 42-92t25-90q1-9-2.5-32t.5-28q4-13 22-30.5t22-22.5q19-26 42.5-84.5t27.5-96.5q1-8-3-25.5t-2-26.5q2-8 9-18t18-23 17-21q8-12 16.5-30.5t15-35 16-36 19.5-32 26.5-23.5 36-11.5 47.5 5.5l-1 3q38-9 51-9h761q74 0 114 56t18 130l-274 906q-36 119-71.5 153.5t-128.5 34.5h-869q-27 0-38 15-11 16-1 43 24 70 144 70h923q29 0 56-15.5t35-41.5l300-987q7-22 5-57 38 15 59 43zm-1064 2q-4 13 2 22.5t20 9.5h608q13 0 25.5-9.5t16.5-22.5l21-64q4-13-2-22.5t-20-9.5h-608q-13 0-25.5 9.5t-16.5 22.5zm-83 256q-4 13 2 22.5t20 9.5h608q13 0 25.5-9.5t16.5-22.5l21-64q4-13-2-22.5t-20-9.5h-608q-13 0-25.5 9.5t-16.5 22.5z"/></svg>Manual</a>
</header>
<div id="content">
<div id="table-of-contents">
<h2>EMF Views User Guide</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#overview">Overview</a></li>
<li><a href="#tutorials">Tutorials</a>
<ul>
<li><a href="#creating-a-view-manually">Creating a view manually</a></li>
<li><a href="#creating-a-view-with-vpdl">Creating a view with VPDL</a>
<ul>
<li><a href="#writing-a-vpdl-file">Writing a VPDL file</a></li>
<li><a href="#using-a-vpdl-file-in-eclipse">Using a VPDL file in Eclipse</a></li>
</ul>
</li>
<li><a href="#creating-a-view-programmatically">Creating a view programmatically</a>
<ul>
<li><a href="#caveats">Caveats</a></li>
<li><a href="#creating-a-weaving-model-programmatically">Creating a weaving model programmatically</a></li>
</ul>
</li>
<li><a href="#querying-a-view-with-ocl">Querying a view with OCL</a>
<ul>
<li><a href="#programmatic-ocl-queries">Programmatic OCL queries</a></li>
</ul>
</li>
<li><a href="#transforming-a-view-with-atl">Transforming a view with ATL</a></li>
<li><a href="#creating-an-html-report-from-a-view">Creating an HTML report from a view</a></li>
</ul>
</li>
<li><a href="#concepts">Concepts</a>
<ul>
<li><a href="#views">Views</a>
<ul>
<li><a href="#eview-and-eviewpoint-files">eview and eviewpoint files</a></li>
<li><a href="#vpdl">VPDL</a></li>
<li><a href="#mel">MEL</a></li>
<li><a href="#java-api">Java API</a></li>
</ul>
</li>
<li><a href="#weaving-models">Weaving models</a>
<ul>
<li><a href="#weaving-model">Weaving model</a></li>
<li><a href="#contributing-model">Contributing model</a></li>
<li><a href="#concrete-element">Concrete element</a></li>
<li><a href="#virtual-link">Virtual link</a></li>
<li><a href="#filter">Filter</a></li>
<li><a href="#virtual-association">Virtual association</a></li>
<li><a href="#virtual-concept">Virtual concept</a></li>
<li><a href="#virtual-property">Virtual property</a></li>
</ul>
</li>
<li><a href="#matching-models">Matching models</a>
<ul>
<li><a href="#adding-new-matching-models">Adding new matching models</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>


<h2 id="overview"><a href="#overview">Overview</a></h2>
<p>
EMF Views is a tool that enables to combine and refine/augment several EMF-based
models into <i>views</i>.  These views behave as regular models: you can navigate,
query and transform them as you would do with any regular model.  This comes in
handy when you want to deal with several related models, for instance.
</p>

<p>
Views can filter any element from its contributing models.  This can be used to
create views focused on particular aspects of related models.  Filters also
enable a form of access control: one can create views that hide sensitive
information coming from one or more models.
</p>

<p>
Views can also augment the contributing models with new elements, attributes or
associations.  This is useful for instance when combining related models: you
can add new associations that link related classes together, allowing you to
navigate or query the view more naturally.
</p>

<p>
Views can be created interactively via <code>eview</code> and <code>eviewpoint</code> definition
files, or can be created programmatically.  Moreover, EMF Views currently comes
with two DSLs that ease the definition of views: <a href="#vpdl">VPDL</a> and <a href="#mel">MEL</a>.
</p>


<h2 id="tutorials"><a href="#tutorials">Tutorials</a></h2>
<p>
These tutorials will take you through the main features of EMF Views.
</p>


<h3 id="creating-a-view-manually"><a href="#creating-a-view-manually">Creating a view manually</a></h3>
<p>
We will create a view linking two related models representing books.
</p>

<p>
In order to create a view, you need the following:
</p>

<ol class="org-ol">
<li>Metamodels.  These can be given as Ecore files, or through the namespace URI
if the packages are loaded as plugins.</li>
<li>Models.  These can be given in any serialization format supported by EMF
(usually XMI).</li>
<li>A <i>viewpoint</i>.  This defines the metamodel of the view.  It is specified
through an <code>eviewpoint</code> file.</li>
<li>An <code>eview</code> file which describes the view.</li>
</ol>

<p>
First, unpack the <code>emfviews-tutorial</code> example.  Here is what the file hierarchy
should look like:
</p>

<pre class="example">
.
├── metamodels
│   ├── Book.ecore
│   └── Publication.ecore
├── models
│   ├── book.xmi
│   └── publication.xmi
├── viewpoints
│   ├── publicationsAndBooks.eviewpoint
│   └── publicationsAndBooks.xmi
└── views
    ├── allChapters.ecl
    ├── allChapters.eview
    ├── firstChapter.ecl
    └── firstChapter.eview
</pre>

<p>
This is one common way to organize views that are created using files, but it is not mandatory to follow this structure.
</p>

<p>
The <code>metamodels</code> folder contains the Ecore files for our two metamodels, Book
and Publication.
</p>


<div class="figure">
<p><img src="images/metamodels.png" alt="metamodels.png">
</p>
</div>

<p>
The Book metamodel has details about each chapter, while the Publication has
more information about the publisher and publishing date.  This is a simple
example of two metamodels with overlapping and complementary information.  The
view we will create will bring all this information under a single (virtual)
metamodel.
</p>

<p>
The <code>models</code> folder contains two serialized models in XMI format that conform to
these metamodels.  Here are the contents of <code>book.xmi</code> (left) and
<code>publication.xmi</code> (right):
</p>


<div class="figure">
<p><img src="images/models.png" alt="models.png">
</p>
</div>

<p>
They both model the same book.  In this example, there is only one
element for simplicity.  In realistic situation, each model may contain several
books or publications.  Our view will work the same with any number of elements.
</p>

<p>
To define the view, we must first define a viewpoint, which acts as a (virtual)
metamodel for the view.  Let us look at the file hierarchy again:
</p>

<pre class="example">
├── viewpoints
│   ├── publicationsAndBooks.eviewpoint
│   └── publicationsAndBooks.xmi
</pre>

<p>
The <code>viewpoints</code> folder contains two files.  Let us focus on the
<code>publicationsAndBooks.eviewpoint</code> file which defines the viewpoint, and is
defined as:
</p>

<pre class="example">
contributingMetamodels=publication::../metamodels/Publication.ecore,\
		       book::../metamodels/Book.ecore
weavingModel=publicationsAndBooks.xmi
</pre>

<p>
(See <a href="#eview-and-eviewpoint-files">eview and eviewpoint files</a> for the full syntax and valid configuration
keys of <code>eviewpoint</code> files.)
</p>

<p>
The first two lines list the <i>contributing metamodels</i>.  These are the two
metamodels we are concerned with.  In this case, we give relative URIs to the
Ecore files in the <code>metamodels</code> folder.  The paths are prefixed by an alias which
will be used to match metamodels to models in the <code>eview</code> file.
</p>

<div class="note">
<p>
We could also have used namespace URIs in <code>contributingModels</code>.  The upside of
pointing to the Ecore files in this case is that EMF Views will load them
without us having to register the EPackages manually.
</p>

</div>

<p>
The third line specifies the <a href="#weaving-models"><i>weaving model</i></a>.  The weaving model describes how
the viewpoint is constructed: it contains filters that select or exclude
elements from the contributing metamodels, and it describes new elements that
are to be added to the viewpoint.  If you omit the <code>weavingModel</code> property, no
elements are filtered or added.
</p>

<p>
Let&rsquo;s try it now.  Remove or comment (<code>#</code> begins a line comment) the
<code>weavingModel</code> line, then save the file.  You have to open the viewpoint in text
mode (Right click &rarr; <code>Open With</code> &rarr; <code>Text Editor</code>).
</p>

<p>
After you have made the change, you want to open the <code>eviewpoint</code> file in a
model editor.  The Sample Ecore Model Editor and the <a href="https://help.eclipse.org/oxygen/topic/org.eclipse.modisco.infrastructure.doc/mediawiki/model_browser/user.html">MoDisco Model Browser</a>
should both be able to do so.  Right click &rarr; <code>Open With</code> &rarr; <code>Other...</code>, and
in the dialog select <code>Sample Ecore Model Editor</code> then click OK:
</p>


<div class="figure">
<p><img src="images/editor-select.png" alt="editor-select.png">
</p>
</div>

<p>
Here is what you should see:
</p>


<div class="figure">
<p><img src="images/viewpoint-empty-weaving.png" alt="viewpoint-empty-weaving.png">
</p>
</div>

<p>
This metamodel combines, under the same <code>viewpoint</code> package, our two metamodels
Publication and Book.  This metamodel is purely virtual: the packages
Publication and Book, and all their elements, are proxies to the actual elements
from the contributing metamodels.
</p>

<p>
Note that the <code>Publication</code> package comes before <code>Book</code> because that is the
order we specified in the <code>contributingMetamodels</code> line in the <code>eviewpoint</code> file.
</p>

<p>
Let us restore the <code>weavingModel</code> line.  First, close the Sample Ecore Model
Editor view of the <code>eviewpoint</code>.  Then, restore or uncomment the <code>weavingModel</code>
line in the <code>eviewpoint</code> by opening it with the Text Editor (or reuse the Text
Editor tab if you had not closed it).  Save the <code>eviewpoint</code> file, and open it
up with the Sample Ecore Model Editor once more.
</p>

<p>
Here is what you should get now:
</p>


<div class="figure">
<p><img src="images/viewpoint.png" alt="viewpoint.png">
</p>
</div>

<p>
There are two differences with the previous viewpoint: there is a new
<code>bookChapters</code> association in the <code>Publication</code> class, and the <code>Chapter.nbPages</code>
attribute has been filtered out.  The <code>bookChapters</code> association enhances the
Publication metamodel by allowing us to navigate the chapters from a
<code>Publication</code> instance.  A <code>Publication</code> in this viewpoint would have all the
information of the <code>Book</code> instance, and more.
</p>

<p>
Note that the <code>Chapter</code> class is part of the <code>Book</code> package (it comes from the
Book metamodel), but it is the target class of an association of the
<code>Publication</code> package.  Combining both metamodels in the viewpoint allows us to
create inter-metamodel associations, since they are now part of the same virtual
metamodel.
</p>

<p>
If we open the weaving model <code>publicationsAndBooks.xmi</code> with the Sample Ecore
Model Editor, we can see that it contains exactly these two changes.  Here is
the viewpoint on the left with the weaving model on the right.  The changes made
by the weaving model to the viewpoint are highlighted:
</p>


<div class="figure">
<p><img src="images/viewpoint-and-weaving.png" alt="viewpoint-and-weaving.png">
</p>
</div>

<p>
Now that we have a viewpoint, all that is left is the view itself.  Let us take
another look at the file hierarchy:
</p>

<pre class="example">
└── views
    ├── allChapters.ecl
    ├── allChapters.eview
    ├── firstChapter.ecl
    └── firstChapter.eview
</pre>

<p>
In the <code>views</code> folder, two views are defined: <code>allChapters</code> and <code>firstChapter</code>.
Let us focus on <code>allChapters</code> for now.  If we look inside <code>allChapters.eview</code>:
</p>

<pre class="example">
contributingModels=publication::../models/publication.xmi,book::../models/book.xmi
viewpoint=../viewpoints/publicationsAndBooks.eviewpoint
matchingModel=allChapters.ecl
</pre>

<p>
(Again, see <a href="#eview-and-eviewpoint-files">eview and eviewpoint files</a> for a complete description of <code>eview</code>
files.)
</p>

<p>
The <code>contributingModels</code> line point to the model resources which contribute to
the view.  Note that the order of the contributing models does not have to match
the order of the <code>contributingMetamodels</code> line in the <code>eviewpoint</code> file.
Metamodels from the <code>eviewpoint</code> file are matched to models using the prefix
alias: <code>pub</code> is the alias for the Publication metamodel, and using the same
alias indicates that the <code>publication.xmi</code> model conforms to it.  The alias is
also used by ECL files, as seen below.
</p>

<p>
The <code>viewpoint</code> line is a relative path to the <code>eviewpoint</code> file.  In order to
define a view, we need to give it a metamodel, which is a viewpoint.
</p>

<p>
Finally, the <code>matchingModel</code> line is a path to an Epsilon Comparison file.  The
matching model contains rules that are used by EMF Views to construct a weaving
model for the view.
</p>

<div class="note">
<p>
EMF Views can be extended to use other matching models beyond ECL.  See <a href="#adding-new-matching-models">Adding
new matching models</a>.
</p>

<p>
Instead of a matching model, you can specify a weaving model directly in the
<code>eview</code> file.  Although the weaving model is usually too tedious to create
manually, it may be a better option when creating views programmatically.
</p>

</div>

<p>
Let us look at this ECL file now:
</p>

<div class="org-src-container">
<pre class="src src-ecl"><span class="org-keyword">rule</span> bookChapters
<span class="org-keyword">match</span> p : publication!Publication
<span class="org-keyword">with</span>  c : book!Chapter
{
  <span class="org-keyword">compare</span>
  {
    <span class="org-keyword">return</span> p.title = c.eContainer().title
       <span class="org-keyword">and</span> p.author = c.eContainer().authorName;
  }
}
</pre>
</div>

<p>
It describes a rule to populate the virtual association <code>bookChapters</code>.  It
considers each publication <code>p</code> from the (concrete) Publication metamodel against
each chapter of the (concrete) Book metamodel; in other words, a Cartesian
product Publication &times; Book.  For each pair <code>(p,c)</code>, if the predicate in
<code>compare</code> is true, then the matching elements are part of the association
<code>bookChapters</code>.
</p>

<p>
Here, if we have a book and a publication that refer to the same ouvrage, then
we want to add all chapters of the book to the association.  Thus, the predicate
checks that the title of the publication is the same as the book&rsquo;s title, and
that they both have the same author, since that is all the common information
between the two metamodels.
</p>

<p>
Note that for our two particular models which describe the same book, the
predicate will always return true.  Hence, we could have written the rule
trivially:
</p>

<div class="org-src-container">
<pre class="src src-ecl">...
  <span class="org-keyword">compare</span>
  {
    <span class="org-keyword">return</span> true;
  }
}
</pre>
</div>

<p>
But the former version will work with models containing more books and
publications.
</p>

<p>
When we open the <code>allChapters.eview</code> file with the MoDisco Model Browser (Right
click &rarr; <code>Open With</code> &rarr; <code>Other...</code>, and select MoDisco Model Browser then
click OK), we can see that the <code>bookChapters</code> associations allows us to navigate
the chapters from the Book model:
</p>


<div class="figure">
<p><img src="images/model-modisco.png" alt="model-modisco.png">
</p>
</div>

<p>
We also can see that the <code>nbPages</code> attribute is absent from the chapters,
because it has been filtered out from the metamodel.
</p>

<p>
Now, we have defined a view that combines the Book and Publication models.  But
we can define multiple views for the same viewpoint.  Take a look at
<code>firstChapter.eview</code>:
</p>

<pre class="example">
contributingModels=publication::../models/publication.xmi,\
		   book::../models/book.xmi
viewpoint=../viewpoints/publicationsAndBooks.eviewpoint
matchingModel=firstChapter.ecl
</pre>

<p>
The only difference with <code>allChapters.eview</code> is the matching model.  For this
view, we want only the <i>first</i> chapter of a matching book to be added to the new
<code>bookChapters</code> association.  Consequently, in <code>firstChapter.ecl</code>, the predicate
is:
</p>

<div class="org-src-container">
<pre class="src src-ecl" id="org6da6005"><span class="org-keyword">return</span> p.title = c.eContainer().title
   <span class="org-keyword">and</span> c = c.eContainer().eContents().first();
</pre>
</div>

<p>
The right-hand part of the condition only matches if the chapter <code>c</code> is the
first one of the book it is part of.
</p>

<p>
As a result, when we open <code>firstChapter.eview</code> with the MoDisco Model Browser,
only one chapter is part of the <code>bookChapters</code> association:
</p>


<div id="orge1c3b82" class="figure">
<p><img src="images/view-first-chapter.png" alt="view-first-chapter.png">
</p>
</div>

<p>
And that&rsquo;s it!  We have created one viewpoint combining two metamodels, then we
created two views combining two models using this viewpoint.  Note that while
this method of creating views with <code>eviewpoint</code> and <code>eview</code> files is suitable
for creating small-scale views interactively, EMF Views offers two other methods
to create views: programmatically and using VPDL.
</p>

<p>
In the next two sections, we will show how we can filter other elements in the
viewpoint, and how we can add new virtual elements.
</p>


<h3 id="creating-a-view-with-vpdl"><a href="#creating-a-view-with-vpdl">Creating a view with VPDL</a></h3>

<h4 id="writing-a-vpdl-file"><a href="#writing-a-vpdl-file">Writing a VPDL file</a></h4>
<p>
VPDL, standing for <i>ViewPoint Description Language</i>, is a domain-specific
language for easing the specification of viewpoints and the creation of
corresponding views using EMF Views.  The syntax of VPDL is inspired by SQL&rsquo;s
<code>SELECT</code> statement.
</p>

<p>
Instead of manually creating <code>eviewpoint</code> and <code>eview</code> files, you write a single
<code>vpdl</code> file which describes the viewpoint and the view at the same time.  Here
is a VPDL file recreating the <code>firstChapter</code> view of the previous section:
</p>

<div class="org-src-container">
<pre class="src src-vpdl"><span class="org-keyword">create</span> <span class="org-keyword">view</span> publicationsAndBooks <span class="org-keyword">as</span>

<span class="org-keyword">select</span> publication.Publication.*,
       publication.Publication <span class="org-keyword">join</span> book.Chapter <span class="org-keyword">as</span> firstChapter,
       book.Book.*,
       book.Chapter.title,

<span class="org-keyword">from</span> <span class="org-string">'http://publication'</span> <span class="org-keyword">as</span> publication,
     <span class="org-string">'http://book'</span> <span class="org-keyword">as</span> book,

<span class="org-keyword">where</span> s.title = t.eContainer().title
      <span class="org-keyword">and</span> t = t.eContainer().eContents().first()
      <span class="org-keyword">for</span> firstChapter
</pre>
</div>

<p>
(See <a href="#vpdl">VPDL</a> for a description of the full syntax.)
</p>

<p>
The first line <code>create view</code> specifies the name of the viewpoint.  This name is
used for generating the <code>eviewpoint</code>, <code>eview</code> and <code>xmi</code> weaving model file.
</p>

<p>
With the <code>select</code> clause, you explicitly select the classes and features from
the contributing metamodels that will appear in the viewpoint.  The <code>select</code>
clause essentially specifies the viewpoint&rsquo;s weaving model, albeit in plain
text.  Here with <code>publication.Publication.*</code> we say that we want all features of
the <code>publication.Publication</code> class in the viewpoint, and by selecting only
<code>book.Chapter.title</code> from <code>book.Chapter</code>, we exclude the <code>nbPages</code> attribute.
The <code>select</code> clause is a whitelist, so if we don&rsquo;t include the <code>book.Book.*</code>
line for instance, the resulting viewpoint would not let us navigate <code>Book</code>
instances, since there would be no visible features.
</p>

<p>
The line:
</p>

<div class="org-src-container">
<pre class="src src-vpdl">publication.Publication <span class="org-keyword">join</span> book.Chapter <span class="org-keyword">as</span> firstChapter,
</pre>
</div>

<p>
tells EMF Views to create a virtual association from <code>Publication</code> to <code>Chapter</code>
called <code>firstChapter</code>.  This is the same as the <code>bookChapter</code> association of the
previous section.
</p>

<p>
The <code>from</code> clause simply maps the namespace URIs of the contributing metamodels
to aliases used in the <code>select</code> clause.
</p>

<p>
Lastly, the <code>where</code> clause specifies, for each new association, how to match
elements from contributing models in the view.  This is used to generate the matching model
as an ECL file.  Here, we use the same predicate as <a href="#org6da6005">before</a>, but this time <code>s</code>
and <code>t</code> refer respectively to the source (<code>Publication</code>) and target (<code>Chapter</code>)
of the association.
</p>


<h4 id="using-a-vpdl-file-in-eclipse"><a href="#using-a-vpdl-file-in-eclipse">Using a VPDL file in Eclipse</a></h4>
<p>
To use a VPDL file, your project need to be configured as an Xtext project in
Eclipse.  If you create a new project and add a <code>vpdl</code> file in it, Eclipse
should prompt you to configure it as an Xtext project.  Otherwise in the
outline, Right click on the project &rarr; <code>Configure</code> &rarr; <code>Convert to Xtext
project</code>.
</p>

<p>
Once the project is configured, whenever you save the <code>vpdl</code> file Xtext should
generate three files: the <code>eviewpoint</code>, the <code>xmi</code> weaving model, and the <code>ecl</code>
matching model.
</p>

<p>
If you unpack the <code>vpdl-tutorial</code> example, here is how the file hierarchy looks
like after we save the <code>publicationAndBooks.vpdl</code> file:
</p>

<pre class="example">
.
├── src
│   └── publicationsAndBooks.vpdl
├── src-gen
│   ├── publicationsAndBooks.ecl
│   ├── publicationsAndBooks.eviewpoint
│   └── publicationsAndBooks.xmi
└── views
    └── firstChapter.eview
</pre>

<p>
All the generated files are in the <code>src-gen</code> directory.
</p>

<p>
To create the view however, we still need an <code>eview</code> file.  VPDL does not create
one for a view (yet).  You just have to point to the generated files, and
specify the contributing models you want to use.  Here is the definition of
<code>firstChapter.eview</code>:
</p>

<div class="org-src-container">
<pre class="src src-sh"><span class="org-variable-name">viewpoint</span>=../src-gen/publicationsAndBooks.eviewpoint
<span class="org-variable-name">contributingModels</span>=<span class="org-sh-escaped-newline">\</span>
  publication::../../emfviews-tutorial/models/publication.xmi,<span class="org-sh-escaped-newline">\</span>
  book::../../emfviews-tutorial/models/book.xmi
<span class="org-variable-name">matchingModel</span>=../src-gen/publicationsAndBooks.ecl
<span class="org-variable-name">weavingModel</span>=publicationAndBooks.xmi
</pre>
</div>

<p>
Opening <code>firstChapter.eview</code> using the MoDisco Model Browser, we get the same
result as <a href="#orge1c3b82">before</a>, the difference being that this time the new association is
more accurately called <code>firstChapter</code>:
</p>


<div class="figure">
<p><img src="images/vpdl-view-first-chapter.png" alt="vpdl-view-first-chapter.png">
</p>
</div>


<h3 id="creating-a-view-programmatically"><a href="#creating-a-view-programmatically">Creating a view programmatically</a></h3>
<p>
In some situations, you may want to create views without touching the
filesystem.  The EMF Views API lets you create views purely in memory, without
creating <code>eview</code> files or <code>vpdl</code> files.
</p>

<div class="note">
<p>
The folder <code>examples/programmatic-view-tutorial</code> contains the full source code
for this section.
</p>

</div>

<p>
Here is a standalone example of creating a minimal view on the <code>UMLPackage</code>
using the API:
</p>

<div class="org-src-container">
<pre class="src src-java"><span class="org-comment-delimiter">// </span><span class="org-comment">1. Create viewpoint</span>
<span class="org-type">Viewpoint</span> <span class="org-variable-name">viewpoint</span> = <span class="org-keyword">new</span> <span class="org-type">Viewpoint</span>(Arrays.asList(UMLPackage.eINSTANCE));

<span class="org-comment-delimiter">// </span><span class="org-comment">2. Create model</span>
<span class="org-type">UMLFactory</span> <span class="org-variable-name">f</span> = UMLFactory.eINSTANCE;
<span class="org-type">Component</span> <span class="org-variable-name">C1</span> = f.createComponent();
C1.setName(<span class="org-string">"Comp1"</span>);
<span class="org-type">Component</span> <span class="org-variable-name">C2</span> = f.createComponent();
C2.setName(<span class="org-string">"Comp2"</span>);

<span class="org-type">Resource</span> <span class="org-variable-name">model</span> = <span class="org-keyword">new</span> <span class="org-type">ResourceImpl</span>();
model.getContents().addAll(Arrays.asList(C1, C2));

<span class="org-comment-delimiter">// </span><span class="org-comment">3. Create view</span>
<span class="org-type">View</span> <span class="org-variable-name">view</span> = <span class="org-keyword">new</span> <span class="org-type">View</span>(viewpoint, Arrays.asList(model));

<span class="org-comment-delimiter">// </span><span class="org-comment">4. Navigate the view</span>
<span class="org-keyword">for</span> (<span class="org-type">EObject</span> <span class="org-function-name">o</span> : view.getVirtualContents()) {
  System.out.println(o.eGet(o.eClass().getEStructuralFeature(<span class="org-string">"name"</span>)));
}
</pre>
</div>

<p>
To create a <code>Viewpoint</code>, we must provide a list of contributing metamodels as
instances of <code>EPackage</code>; here we give the <code>UMLPackage</code> metamodel.  We do not
provide a weaving model, so a default empty weaving model is used instead.  With
an empty weaving model, no elements are filtered out from the contributing
metamodels, and no new elements are added.
</p>

<p>
Then we build the model using the <code>UMLFactory</code>.  We keep it simple for the
purposes of example: just two <code>Component</code> instances.  In a realistic situation,
this model could come from anywhere, as long as we have a resource to provide to
the <code>View</code> constructor.
</p>

<p>
The third step is to create the view by passing the viewpoint and a list of
contributing models as instances of <code>Resource</code> to <code>View</code>.  Here we pass the
model resource we just constructed.  The third optional argument to the <code>View</code>
constructor is the view weaving model.  As for <code>Viewpoint</code>, an empty weaving
model is used if unspecified.
</p>

<p>
Finally, we navigate the view to print the name of the components inside it.
Since we have used empty weaving models, the view is identical in content to the
model.  Running this snippet will output the names of the two components:
</p>

<pre class="example">
Comp1
Comp2
</pre>


<h4 id="caveats"><a href="#caveats">Caveats</a></h4>
<p>
Note that we <i>have</i> to use the reflective EMF API when navigating views, because
there is no corresponding generated code.  View elements are always dynamic
objects.  In other words, it would be tempting, but wrong, to navigate the view
as follows:
</p>

<div class="org-src-container">
<pre class="src src-java"><span class="org-keyword">for</span> (<span class="org-type">EObject</span> <span class="org-function-name">o</span> : view.getVirtualContents()) {
  <span class="org-type">Component</span> <span class="org-variable-name">c</span> = (<span class="org-type">Component</span>) o;   <span class="org-comment-delimiter">// </span><span class="org-comment">this cast will fail</span>
  System.out.println(c.getName());
}
</pre>
</div>

<p>
This code will compile, but will raise a <code>ClassCastException</code> at runtime.  For
the same reasons, testing for instances with <code>instanceof</code> will not work with the
current version of EMF Views:
</p>

<div class="org-src-container">
<pre class="src src-java"><span class="org-keyword">for</span> (<span class="org-type">EObject</span> <span class="org-function-name">o</span> : view.getVirtualContents()) {
  <span class="org-keyword">if</span> (o <span class="org-keyword">instanceof</span> Component) {  <span class="org-comment-delimiter">// </span><span class="org-comment">this can never be true</span>
    ...
  }
}
</pre>
</div>

<p>
For testing instances, you have to use the reflective API.  But be careful about
using the metaclasses from <i>viewpoint</i> and not from the original <code>UMLPackage</code>.
The following is wrong:
</p>

<div class="org-src-container">
<pre class="src src-java"><span class="org-type">EClassifier</span> <span class="org-variable-name">comp</span> = UMLPackage.eINSTANCE.getComponent();
<span class="org-keyword">for</span> (<span class="org-type">EObject</span> <span class="org-function-name">o</span> : view.getVirtualContents()) {
  <span class="org-keyword">if</span> (comp.isInstance(o)) {      <span class="org-comment-delimiter">// </span><span class="org-comment">this test can still never be true</span>
    ...
  }
}
</pre>
</div>

<p>
The view conforms to the viewpoint, and elements of the viewpoint <i>refer</i> to
elements from <code>UMLPackage</code>, but they are not equal.  The correct way of finding
<code>Component</code> instances is by getting the <code>Component</code> metaclass from the virtual
<code>UMLPackage</code>:
</p>

<div class="org-src-container">
<pre class="src src-java"><span class="org-type">EPackage</span> <span class="org-variable-name">vUML</span> = viewpoint.getRootPackage().getESubpackages().get(0);
<span class="org-type">EClassifier</span> <span class="org-variable-name">comp</span> = vUML.getEClassifier(<span class="org-string">"Component"</span>);
<span class="org-keyword">for</span> (<span class="org-type">EObject</span> <span class="org-function-name">o</span> : view.getVirtualContents()) {
  <span class="org-keyword">if</span> (comp.isInstance(o)) {
    ...
  }
}
</pre>
</div>


<h4 id="creating-a-weaving-model-programmatically"><a href="#creating-a-weaving-model-programmatically">Creating a weaving model programmatically</a></h4>
<p>
We have seen how to create viewpoints and views programmatically, but only with
empty weaving models.  Let&rsquo;s recreate the publications and books view from the
other tutorials, but this time without creating any <code>eview</code>, <code>eviewpoint</code> or
<code>vpdl</code> file.
</p>

<p>
For simplicity, we&rsquo;ll assume the Book and Publication metamodels and models are
already loaded.
</p>

<div class="org-src-container">
<pre class="src src-java"><span class="org-type">EPackage</span> <span class="org-variable-name">Book</span> = ... <span class="org-comment-delimiter">// </span><span class="org-comment">load the Book.ecore metamodel</span>
EPackage Publ = ... <span class="org-comment-delimiter">// </span><span class="org-comment">load the Publication.ecore metamodel</span>

Resource book = ... <span class="org-comment-delimiter">// </span><span class="org-comment">load the book.xmi model</span>
Resource publ = ... <span class="org-comment-delimiter">// </span><span class="org-comment">load the publication.xmi model</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">1. Build the viewpoint weaving model</span>
VirtualLinksFactory f = VirtualLinksFactory.eINSTANCE;
<span class="org-type">WeavingModel</span> <span class="org-variable-name">WM1</span> = f.createWeavingModel();
WM1.setName(<span class="org-string">"publicationsAndBooks"</span>);

<span class="org-type">ConcreteConcept</span> <span class="org-variable-name">source</span>;
{
  <span class="org-type">ContributingModel</span> <span class="org-variable-name">cm</span> = f.createContributingModel();
  WM1.getContributingModels().add(cm);
  cm.setURI(<span class="org-string">"http://publication"</span>);
  <span class="org-type">ConcreteConcept</span> <span class="org-variable-name">cc</span> = f.createConcreteConcept();
  cm.getConcreteElements().add(cc);
  cc.setPath(<span class="org-string">"Publication"</span>);
  source = cc;
}

<span class="org-type">ConcreteConcept</span> <span class="org-variable-name">target</span>;
<span class="org-type">ConcreteElement</span> <span class="org-variable-name">nbPages</span>;
{
  <span class="org-type">ContributingModel</span> <span class="org-variable-name">cm</span> = f.createContributingModel();
  WM1.getContributingModels().add(cm);
  cm.setURI(<span class="org-string">"http://book"</span>);
  <span class="org-type">ConcreteConcept</span> <span class="org-variable-name">cc</span> = f.createConcreteConcept();
  cm.getConcreteElements().add(cc);
  cc.setPath(<span class="org-string">"Chapter"</span>);
  target = cc;
  <span class="org-type">ConcreteElement</span> <span class="org-variable-name">ce</span> = f.createConcreteElement();
  cm.getConcreteElements().add(ce);
  ce.setPath(<span class="org-string">"Chapter.nbPages"</span>);
  nbPages = ce;
}

{
  <span class="org-type">VirtualAssociation</span> <span class="org-variable-name">va</span> = f.createVirtualAssociation();
  WM1.getVirtualLinks().add(va);
  va.setName(<span class="org-string">"bookChapters"</span>);
  va.setUpperBound(-1);
  va.setSource(source);
  va.setTarget(target);
}

{
  <span class="org-type">Filter</span> <span class="org-variable-name">fi</span> = f.createFilter();
  WM1.getVirtualLinks().add(fi);
  fi.setName(<span class="org-string">"nbPages"</span>);
  fi.setTarget(nbPages);
}

<span class="org-comment-delimiter">// </span><span class="org-comment">2. Build the viewpoint</span>
<span class="org-type">Viewpoint</span> <span class="org-variable-name">viewpoint</span> = <span class="org-keyword">new</span> <span class="org-type">Viewpoint</span>(Arrays.asList(Book, Publ), WM1);

<span class="org-comment-delimiter">// </span><span class="org-comment">3. Build the view weaving model</span>
<span class="org-type">WeavingModel</span> <span class="org-variable-name">WM2</span> = f.createWeavingModel();
WM2.setName(<span class="org-string">"publicationsAndBooks"</span>);

{
  <span class="org-type">ContributingModel</span> <span class="org-variable-name">cm</span> = f.createContributingModel();
  WM2.getContributingModels().add(cm);
  cm.setURI(<span class="org-string">"http://publication"</span>);
  <span class="org-type">ConcreteConcept</span> <span class="org-variable-name">cc</span> = f.createConcreteConcept();
  cm.getConcreteElements().add(cc);
  <span class="org-type">EObject</span> <span class="org-variable-name">o</span> = publ.getContents().get(0);
  cc.setPath(publ.getURIFragment(o));
  source = cc;
}

{
  <span class="org-type">ContributingModel</span> <span class="org-variable-name">cm</span> = f.createContributingModel();
  WM2.getContributingModels().add(cm);
  cm.setURI(<span class="org-string">"http://book"</span>);
  <span class="org-type">ConcreteConcept</span> <span class="org-variable-name">cc</span> = f.createConcreteConcept();
  cm.getConcreteElements().add(cc);
  <span class="org-type">EObject</span> <span class="org-variable-name">o</span> = book.getContents().get(0).eContents().get(0);
  cc.setPath(book.getURIFragment(o));
  target = cc;
}

{
  <span class="org-type">VirtualAssociation</span> <span class="org-variable-name">va</span> = f.createVirtualAssociation();
  WM2.getVirtualLinks().add(va);
  va.setName(<span class="org-string">"bookChapters"</span>);
  va.setSource(source);
  va.setTarget(target);
}

<span class="org-comment-delimiter">// </span><span class="org-comment">4. Build the view</span>
<span class="org-type">View</span> <span class="org-variable-name">view</span> = <span class="org-keyword">new</span> <span class="org-type">View</span>(viewpoint, Arrays.asList(book, publ), WM2);

<span class="org-comment-delimiter">// </span><span class="org-comment">5. Navigate the new association in the view</span>
<span class="org-type">EObject</span> <span class="org-variable-name">vpubl</span> = view.getVirtualContents().get(1);
System.out.println(vpubl.eGet(vpubl.eClass().getEStructuralFeature(<span class="org-string">"title"</span>)));

<span class="org-type">EStructuralFeature</span> <span class="org-variable-name">assoc</span> = vpubl.eClass().getEStructuralFeature(<span class="org-string">"bookChapters"</span>);
<span class="org-type">EObject</span> <span class="org-variable-name">vchapter</span> = ((<span class="org-type">EList</span>&lt;<span class="org-type">EObject</span>&gt;) vpubl.eGet(assoc)).get(0);
System.out.println(
  vchapter.eGet(vchapter.eClass().getEStructuralFeature(<span class="org-string">"title"</span>)));
</pre>
</div>

<p>
As you can see, creating weaving model programmatically can be quite tedious,
but this is the option that gives you the most control.  In a real program, you
may want to create helper functions that take care of the boilerplate,
especially when building weaving models for views which can contain many
elements.  Here, thankfully, we just had to add one chapter to the virtual
association.
</p>

<p>
When executing this snippet, we get the following output:
</p>

<pre class="example">
ATL in Depth
Introduction to ATL
</pre>


<h3 id="querying-a-view-with-ocl"><a href="#querying-a-view-with-ocl">Querying a view with OCL</a></h3>
<p>
To query a view interactively, you can use the standard OCL console.  Refer to
the <a href="https://help.eclipse.org/oxygen/topic/org.eclipse.ocl.doc/help/InteractiveOCL.html">OCL documentation</a> on how to bring up the OCL console.  Once you have a
console open, you can query a view using OCL expressions:
</p>


<div class="figure">
<p><img src="images/ocl-query.png" alt="ocl-query.png">
</p>
</div>

<p>
In this figure, we see the <code>allChapters.eview</code> view open in the MoDisco Model
Browser, with the Xtext OCL console on the lower half.  When the <code>[Publication]
ATL in Depth</code> object is selected in MoDisco, it becomes the context object
(<code>self</code>) for the OCL console, as indicated by the text <code>Xtext OCL for
'Publication…'</code>.
</p>

<p>
In the console, we can see the results of executing the OCL query:
</p>

<pre class="example">
self.bookChapters-&gt;collect(c | c.title)
</pre>

<p>
which collects the titles of all the chapters in this publication in an set,
using the <code>bookChapters</code> virtual association.
</p>


<h4 id="programmatic-ocl-queries"><a href="#programmatic-ocl-queries">Programmatic OCL queries</a></h4>
<p>
You can also use OCL programmatically.  Here is an example of code using the OCL
Pivot API which the run the same query as above:
</p>

<div class="org-src-container">
<pre class="src src-java"><span class="org-comment-delimiter">// </span><span class="org-comment">Initialize EMF</span>
<span class="org-type">Map</span>&lt;<span class="org-type">String</span>, <span class="org-type">Object</span>&gt; <span class="org-variable-name">map</span> = <span class="org-constant">Resource</span>.<span class="org-constant">Factory</span>.<span class="org-constant">Registry</span>.INSTANCE
  .getExtensionToFactoryMap();
map.put(<span class="org-string">"xmi"</span>, <span class="org-keyword">new</span> <span class="org-type">XMIResourceFactoryImpl</span>());
map.put(<span class="org-string">"ecore"</span>, <span class="org-keyword">new</span> <span class="org-type">EcoreResourceFactoryImpl</span>());
map.put(<span class="org-string">"eview"</span>, <span class="org-keyword">new</span> <span class="org-type">EmfViewsFactory</span>());

<span class="org-comment-delimiter">// </span><span class="org-comment">Make sure the weaving model package is loaded</span>
VirtualLinksPackage.eINSTANCE.eClass();

<span class="org-comment-delimiter">// </span><span class="org-comment">Register EclDelegate as handler for ".ecl" weaving models</span>
VirtualLinksDelegator.register(<span class="org-string">"ecl"</span>, <span class="org-keyword">new</span> <span class="org-type">EclDelegate</span>());

<span class="org-comment-delimiter">// </span><span class="org-comment">Initialize OCL</span>
<span class="org-type">OCL</span> <span class="org-variable-name">ocl</span> = OCL.newInstance(<span class="org-constant">EcoreEnvironmentFactory</span>.INSTANCE);
<span class="org-type">OCLHelper</span> <span class="org-variable-name">oclHelper</span> = ocl.createOCLHelper();

<span class="org-comment-delimiter">// </span><span class="org-comment">Load the view</span>
<span class="org-type">Resource</span> <span class="org-variable-name">view</span>  = <span class="org-keyword">new</span> <span class="org-type">ResourceSetImpl</span>()
  .getResource(URI.createURI(<span class="org-string">"allChapters.eview"</span>), <span class="org-constant">true</span>);
view.load(<span class="org-constant">null</span>);

<span class="org-comment-delimiter">// </span><span class="org-comment">Set the query context</span>
<span class="org-type">EObject</span> <span class="org-variable-name">root</span> = view.getContents().get(0);
<span class="org-type">EObject</span> <span class="org-variable-name">context</span> = root.eClass();
oclHelper.setContext(context);

<span class="org-comment-delimiter">// </span><span class="org-comment">Create the query</span>
<span class="org-type">Query</span> <span class="org-variable-name">query</span> = ocl.createQuery(
  oclHelper.createQuery(<span class="org-string">"self.bookChapters-&gt;collect(c | c.title)"</span>));

<span class="org-comment-delimiter">// </span><span class="org-comment">Evaluate and print result</span>
System.out.println(<span class="org-string">"Result: "</span> + query.evaluate(root));
</pre>
</div>

<p>
Running that program yields:
</p>

<pre class="example">
Result: [Introduction to ATL,
         An Example Transformation,
         A Couple of Compilers,
         ATL Harder]
</pre>


<h3 id="transforming-a-view-with-atl"><a href="#transforming-a-view-with-atl">Transforming a view with ATL</a></h3>
<p>
As views appear as regular EMF models to EMF-compatible tools, you can use a view
as an input to a model-to-model transformation, or to a model-to-text one (see
the <a href="#creating-an-html-report-from-a-view">next tutorial</a>).
</p>

<div class="note">
<p>
This tutorial still needs to be written.  Come back later!
</p>

</div>


<h3 id="creating-an-html-report-from-a-view"><a href="#creating-an-html-report-from-a-view">Creating an HTML report from a view</a></h3>
<p>
To create an HTML report from a view, we will use the <a href="https://www.eclipse.org/epsilon/doc/egl/">Epsilon Generation
Language</a>.
</p>

<p>
In the <code>view-to-html-tutorial</code>, you can find the following files:
</p>

<pre class="example">
.
├── metamodels
│   ├── Book.ecore
│   └── Publication.ecore
├── models
│   ├── book.xmi
│   └── publication.xmi
├── templates
│   ├── publicationsAndBooks.egl
│   └── publicationsAndBooks.launch
├── viewpoints
│   ├── publicationsAndBooks.eviewpoint
│   └── publicationsAndBooks.xmi
└── views
    ├── allChapters.ecl
    └── allChapters.eview
</pre>

<p>
These are the same files from the <code>emfviews-tutorial</code>, except there&rsquo;s a new
<code>templates</code> folder that contains an EGL file and a launch configuration.
</p>

<p>
The EGL file is rather straightforward:
</p>

<div class="org-src-container">
<pre class="src src-html">[% for (p in Publication.allInstances()) { %]
&lt;<span class="org-function-name">p</span>&gt;
  &lt;<span class="org-function-name">i</span>&gt;<span class="org-italic">[%=p.title%]</span>&lt;/<span class="org-function-name">i</span>&gt;, [%=p.author%], [%=p.publisher%] ([%=p.year%])&lt;<span class="org-function-name">br</span>&gt;
  Contents:
  &lt;<span class="org-function-name">ol</span>&gt;
  [% for (c in p.bookChapters) { %]
    &lt;<span class="org-function-name">li</span>&gt;[%=c.title%]&lt;/<span class="org-function-name">li</span>&gt;
  [% } %]
  &lt;/<span class="org-function-name">ol</span>&gt;
&lt;/<span class="org-function-name">p</span>&gt;
[% } %]
</pre>
</div>

<p>
(Refer to the <a href="https://www.eclipse.org/epsilon/doc/egl/">EGL documentation</a> for the language syntax and examples.)
</p>

<p>
This example goes through all publications in the view, and for each it lists
all its attribute and all its chapters.
</p>

<p>
To execute this template, we need a launch configuration.  One is provided in
the <code>templates</code> folder; you should be able to import it.  Otherwise, you can
create a new <code>EGL Generator</code> launch configuration, and configure it as follows:
</p>


<div class="figure">
<p><img src="images/egl-launch-config1.png" alt="egl-launch-config1.png">
</p>
</div>


<div class="figure">
<p><img src="images/egl-launch-config2.png" alt="egl-launch-config2.png">
</p>
</div>

<p>
The important part is to use the <code>eview</code> file as <code>Model file</code>, and the
<code>eviewpoint</code> file as <code>Metamodels</code>.  The configurator may add the namespace URI
of the viewpoint in the <code>Metamodels</code> list when you add the <code>eview</code> file.  You
should remove it, and point to the <code>eviewpoint</code> file instead.
</p>

<div class="note">
<p>
You can also run the EGL template programmatically.  Refer to the <a href="https://www.eclipse.org/epsilon/doc/articles/code-generation-tutorial-egl/">Epsilon
documentation</a> for examples on how to do that.
</p>

</div>

<p>
Before we can run this configuration, we need to make a minor change to the
<code>eviewpoint</code> file.  We add the <code>saveInRegistry</code> option:
</p>

<pre class="example">
contributingMetamodels=publication::../metamodels/Publication.ecore,\
		       book::../metamodels/Book.ecore
weavingModel=publicationsAndBooks.xmi
saveInRegistry
</pre>

<p>
The reason this is necessary is because EGL will load the <code>eview</code> and
<code>eviewpoint</code> resources separately, and we need the view to find the created
viewpoint at runtime.  When opening views in model editors, this option is not
necessary since the view will take care of instantiating the viewpoint directly.
</p>

<div class="note">
<p>
Refer to the <a href="#org3a2f4fc"><code>saveInRegistry</code> option documentation</a> for more details.
</p>

</div>

<p>
Once this is taken care of, we can finally execute the EGL template on our
view.  After a few seconds, the console should output the line:
</p>

<pre class="example">
Output generated to /view-to-html-tutorial/templates/out.html
</pre>

<p>
The generated HTML should look like this:
</p>

<div class="org-src-container">
<pre class="src src-html">&lt;<span class="org-function-name">p</span>&gt;
  &lt;<span class="org-function-name">i</span>&gt;<span class="org-italic">ATL in Depth</span>&lt;/<span class="org-function-name">i</span>&gt;, A. Tlanmod, Willy (2022)&lt;<span class="org-function-name">br</span>&gt;
  Contents:
  &lt;<span class="org-function-name">ol</span>&gt;arst
    &lt;<span class="org-function-name">li</span>&gt;Introduction to ATL&lt;/<span class="org-function-name">li</span>&gt;
    &lt;<span class="org-function-name">li</span>&gt;An Example Transformation&lt;/<span class="org-function-name">li</span>&gt;
    &lt;<span class="org-function-name">li</span>&gt;A Couple of Compilers&lt;/<span class="org-function-name">li</span>&gt;
    &lt;<span class="org-function-name">li</span>&gt;ATL Harder&lt;/<span class="org-function-name">li</span>&gt;
  &lt;/<span class="org-function-name">ol</span>&gt;
&lt;/<span class="org-function-name">p</span>&gt;
</pre>
</div>

<p>
And if we open that file in a web browser, here is the result:
</p>


<div class="figure">
<p><img src="images/egl-result.png" alt="egl-result.png">
</p>
</div>

<p>
Generating an HTML page from a model can make for more pleasant reports.  With
the right amount of CSS and JavaScript, you can even have build interactive
visualizations from your views.  See the <code>traceability-demo</code> in the examples
folder for a more involved usage of templates.
</p>


<h2 id="concepts"><a href="#concepts">Concepts</a></h2>

<h3 id="views"><a href="#views">Views</a></h3>
<p>
In EMF Views, views are lightweight (virtual) models that can rely on one or
several contributing models.  Thus, they allow you to access their contributing
models transparently.
</p>

<p>
There are three ways to create a view:
</p>

<ol class="org-ol">
<li>By writing an <a href="#eview-and-eviewpoint-files"><code>eview</code> (and an <code>eviewpoint</code>) file</a>.</li>
<li>By writing a <a href="#vpdl">VPDL file</a>.</li>
<li>By using the EMF Views <a href="#java-api">API</a>.</li>
</ol>

<p>
The <code>VPDL</code> method is the fastest for interactive creation, but the <code>eview</code>
approach is more flexible.  Using the API should be preferred when creating
views from Java code.
</p>

<p>
The <code>MEL</code> DSL lets you create viewpoints easily, but to obtain a view you still
need to create a view weaving model.
</p>


<h4 id="eview-and-eviewpoint-files"><a href="#eview-and-eviewpoint-files">eview and eviewpoint files</a></h4>
<p>
The <code>eview</code> and <code>eviewpoint</code> files respectively describe views and viewpoints.
</p>

<p>
In Eclipse, the EMF Views plugin installs parsers for these file extensions
through the <code>org.eclipse.emf.ecore.extension_parser</code> extension point. This means
you are able to open <code>eview</code> and <code>eviewpoint</code> files in standard EMF model
editors such as the Sample Ecore Model Editor, or the <a href="https://help.eclipse.org/oxygen/topic/org.eclipse.modisco.infrastructure.doc/mediawiki/model_browser/user.html">MoDisco Model Browser</a>.
</p>

<p>
The syntax of these files follows the text encoding of <code>java.util.Properties</code>.
That is, the file is a list of properties as <code>KEY=VALUE</code> pairs, where both <code>KEY</code>
and <code>VALUE</code> are strings:
</p>

<div class="org-src-container">
<pre class="src src-sh"><span class="org-variable-name">key1</span>=thisisavalue
<span class="org-comment-delimiter"># </span><span class="org-comment">a pound begins a line comment</span>
<span class="org-variable-name">key2</span>=everything to the right of the equals is a value
<span class="org-comment-delimiter"># </span><span class="org-comment">Values can span multiple lines by escaping newlines with a backslash</span>
<span class="org-variable-name">key3</span>=value spanning<span class="org-sh-escaped-newline">\</span>
     multiple lines
</pre>
</div>

<p>
For <code>eviewpoint</code> files, these are the accepted properties:
</p>

<dl class="org-dl">
<dt><code>contributingMetamodels</code></dt><dd>Comma-separated list of alias-URI pairs to
contributing metamodels.  The alias and URI are separated by two colons
<code>::</code>.  This key is mandatory.</dd>

<dt><code>weavingModel</code></dt><dd>URI for the viewpoint&rsquo;s <a href="#weaving-models">weaving model</a>.  This key is
optional; if unspecified, the viewpoint will be constructed with an empty
weaving model.</dd>

<dt><code>saveInRegistry</code> <a id="org3a2f4fc"></a></dt><dd><p>
(Optional).  If this property is
present, the viewpoint created from the <code>eviewpoint</code> file will be saved in
an internal registry, using the <code>eviewpoint</code> file location as a key.  This
means that <code>eview</code> files pointing to the viewpoint will now attempt to load
it from the registry.  This is necessary for EMF-based tools that expect a
model and a metamodel separately (e.g., EGL).
</p>

<p>
The value of this property is ignored.
</p></dd>

<dt><code>strictEcore</code></dt><dd><p>
(Optional).  If this property is present, the metamodel
generated in the viewpoint will be checked with the Ecore diagnostician.
Views will usually work even if the viewpoint is an invalid Ecore
metamodel, but some modeling tools may be stricter.  If this option is
enabled, and the viewpoint has errors, loading the viewpoint as a resource
will produce an exception and the list of diagnostics will be attached to
the resource.
</p>

<p>
The value of this property is ignored.
</p></dd>
</dl>

<p>
URIs are built using <code>org.eclipse.emf.common.util.URI.createURI</code>.  This allows
you to specify files using the <code>file</code> or <code>platform</code> schemes.  Without an
explicit scheme, the file one is used by default.  Note that relative file paths
are resolved relatively to the location of the <code>eviewpoint</code> file.
</p>

<p>
For metamodels, you can specify either the location of an <code>ecore</code> file with the
above schemes, or if the URI begins with <code>http://</code> it is taken to be the
namespace URI of the <code>EPackage</code> and is looked up in the Ecore package registry.
</p>

<p>
Here is an example of a valid <code>eviewpoint</code> file:
</p>

<pre class="example">
contributingMetamodels=book::../metamodels/Book.ecore,\
                       uml::http://www.eclipse.org/uml2/5.0.0/UML
weavingModel=books-and-uml.xmi
</pre>

<p>
Here the <code>Book.ecore</code> metamodel is loaded through a relative file URI, and the
UML metamodel through its namespace URI.
</p>

<p>
<code>eview</code> files have 4 valid properties:
</p>

<dl class="org-dl">
<dt><code>viewpoint</code></dt><dd>URI to the <code>eviewpoint</code> file.  This key is mandatory.</dd>
<dt><code>contributingModels</code></dt><dd>Comma-separated list of alias-URI pairs to
contributing models.  The alias and URI are separated by two colons <code>::</code>.
This key is mandatory.</dd>
<dt><code>weavingModel</code></dt><dd>URI to the view&rsquo;s <a href="#weaving-models">weaving model</a>.  This key conflicts with
<code>matchingModel</code>.</dd>
<dt><code>matchingModel</code></dt><dd>URI to a supported <a href="#matching-models">matching model</a>.  This key conflicts with
<code>weavingModel</code>.</dd>
</dl>

<p>
Since the purpose of the matching model is to create the weaving model used by
the view, you must give exactly one of the keys { <code>matchingModel</code>,
<code>weavingModel</code> }.
</p>

<p>
All file URIs are resolved relatively to the <code>eview</code> file&rsquo;s location.
</p>

<p>
Here is an example of a valid <code>eview</code> file:
</p>

<pre class="example">
viewpoint=../viewpoints/booksAndPub.eviewpoint
contributingModels=book::models/book.xmi,publication::../../publication.xmi
matchingModel=booksAndPub.ecl
</pre>

<p>
For a step-by-step guide on creating views with <code>eview</code> files, see <a href="#creating-a-view-manually">Creating a view manually</a>.
</p>


<h4 id="vpdl"><a href="#vpdl">VPDL</a></h4>
<p>
VPDL, standing for <i>ViewPoint Description Language</i>, is a domain-specific
language for easing the creation of views and viewpoints when using EMF Views.
The syntax of VPDL is inspired by the syntax of the SQL&rsquo;s <code>SELECT</code> statement.
</p>

<p>
This is an overview of the structure of a VPDL file:
</p>

<div class="org-src-container">
<pre class="src src-vpdl"><span class="org-keyword">create</span> <span class="org-keyword">view</span> <span class="org-comment-delimiter">/* </span><span class="org-comment">view-name */</span> <span class="org-keyword">as</span>

<span class="org-keyword">select</span> <span class="org-comment-delimiter">// </span><span class="org-comment">features and new associations</span>

<span class="org-keyword">from</span> <span class="org-comment-delimiter">// </span><span class="org-comment">contributing metamodels</span>

<span class="org-keyword">where</span> <span class="org-comment-delimiter">// </span><span class="org-comment">matching rules for new associations</span>
</pre>
</div>

<p>
There are three clauses:
</p>

<dl class="org-dl">
<dt><code>select</code></dt><dd><p>
Specifies which contributing metamodel features to include in the
view, and which new associations (if any) to create between models.
</p>

<p>
To select a feature, you write its dot-separated path:
</p>

<div class="verbatim">
<p>
<i>metamodel</i> . <i>class</i> . <i>feature</i>
</p>

</div>

<p>
where <i>metamodel</i> is the alias given to the metamodel in the <code>from</code> clause.
E.g., <code>uml.Component.name</code> will include the <code>name</code> feature of the
<code>Component</code> class in the metamodel called <code>uml</code>.
</p>

<p>
You can select multiple features from the same class by using square
brackets: <code>uml.Component[name, role]</code> is equivalent to:
</p>

<pre class="example">
uml.Component.name,
uml.Component.role
</pre>

<p>
Lastly, you can include all features of a class using a wildcard:
<code>uml.Component.*</code>.
</p>

<p>
You create new associations between two classes with a <code>join</code> statement:
</p>

<div class="verbatim">
<p>
<i>metamodel</i> . <i>class1</i> join <i>metamodel</i> . <i>class2</i> as <i>name</i>
</p>

</div>

<p>
This will add a virtual association feature named <code>name</code> in <code>class1</code> with
type <code>class2</code>.  Note that this does not specify <i>how</i> the association will
be populated based on model contents.  For that, you have to use the
<code>where</code> clause.
</p>

<p>
The <code>select</code> clause is mandatory.  At the very least, you must include one
feature (otherwise the view will be empty and you could use an empty
weaving model directly instead of writing a VPDL file).
</p></dd>

<dt><code>from</code></dt><dd><p>
Specifies the metamodels contributing to the viewpoint.
</p>

<div class="verbatim">
<p>
<i>namespace-uri</i> as <i>alias</i>
</p>

</div>

<p>
The metamodels are given through their namespace URIs, and an alias must be
given and used in the <code>select</code> clause.
</p>

<p>
This clause is mandatory.
</p></dd>

<dt><code>where</code></dt><dd><p>
Specifies the rules used for populating new associations by
matching model elements.
</p>

<p>
The rules are written in a subset of ECL expressions.  The top-level
variables <code>s</code> and <code>t</code> will be bound respectively to the source model and
target model of the association when creating the view.
</p>

<p>
This clause is optional.
</p></dd>
</dl>

<p>
Here is an example of a VPDL file:
</p>

<div class="org-src-container">
<pre class="src src-vpdl"><span class="org-keyword">create</span> <span class="org-keyword">view</span> threeModelComposition <span class="org-keyword">as</span>

<span class="org-keyword">select</span>
    togaf.Requirement <span class="org-keyword">join</span> reqif.SpecObject <span class="org-keyword">as</span> detailedRequirement,
    togaf.Process <span class="org-keyword">join</span> bpmn.Process <span class="org-keyword">as</span> detailedProcess,

    togaf.Process.isAutomated,
    togaf.Requirement[statementOfRequirement, acceptanceCriteria],
    reqif.SpecObject.type,
    bpmn.Process[isClosed, isExecutable, processType],

    togaf.Element.name,
    togaf.EnterpriseArchitecture.architectures,
    togaf.StrategicArchitecture.strategicElements,
    togaf.BusinessArchitecture.processes,

    reqif.ReqIFContent.specObjects,
    reqif.ReqIF.coreContent,
    reqif.Identifiable[desc, longName],

    bpmn.Definitions[name, rootElements],
    bpmn.CallableElement.name,

<span class="org-keyword">from</span>
  <span class="org-string">'http://www.obeonetwork.org/dsl/togaf/contentfwk/9.0.0'</span> <span class="org-keyword">as</span> togaf,
  <span class="org-string">'http://www.omg.org/spec/BPMN/20100524/MODEL-XMI'</span>       <span class="org-keyword">as</span> bpmn,
  <span class="org-string">'http://www.omg.org/spec/ReqIF/20110401/reqif.xsd'</span>      <span class="org-keyword">as</span> reqif,

<span class="org-keyword">where</span> s.name = t.name <span class="org-keyword">and</span> s.isAutomated = false <span class="org-keyword">for</span> detailedProcess,
      t.values.exists(v | v.theValue=s.name)    <span class="org-keyword">for</span> detailedRequirement,
</pre>
</div>

<p>
The following diagram outlines the VPDL grammar; <a href="https://raw.githubusercontent.com/atlanmod/emfviews/master/dsls/vpdl/org.atlanmod.emfviews.vpdl/src/org/atlanmod/emfviews/vpdl/Vpdl.xtext">the full Xtext grammar</a> can be
found in the source code.
</p>


<div class="figure">
<p><img src="images/vpdl-grammar.svg" class="no-shadow"/>
</p>
</div>

<p>
The tutorial <a href="#creating-a-view-with-vpdl">Creating a view with VPDL</a> takes you through creating a VPDL file
and using it in Eclipse.
</p>


<h4 id="mel"><a href="#mel">MEL</a></h4>
<p>
While <a href="#vpdl">VPDL</a> allows you to combine metamodels in the same view, it only allows you
to filter classes and features from these metamodels.  On the other hand,
viewpoint <a href="#weaving-models">weaving models</a> allow you to add new classes and properties, and modify
existing ones, but are harder to specify manually.
</p>

<p>
MEL is the <i>Metamodel Extension Language</i>, a domain-specific language for
creating viewpoints that extends multiple existing metamodels.
</p>

<p>
Here is an example of a simple MEL file:
</p>

<div class="org-src-container">
<pre class="src src-mel"><span class="org-keyword">import</span> uml <span class="org-keyword">from</span> <span class="org-string">'http://www.eclipse.org/uml2/5.0.0/UML'</span>

<span class="org-keyword">define</span> single_inheritance_uml <span class="org-keyword">extending</span> uml {
  <span class="org-keyword">modify</span> <span class="org-keyword">class</span> uml.Class {
    <span class="org-keyword">modify</span> <span class="org-keyword">association</span> superClass {
      <span class="org-keyword">cardinality</span> 0..1
    }
  }
}
</pre>
</div>

<p>
This MEL file defines a new viewpoint, <code>single_inheritance_uml</code> that changes
exactly one thing from the original UML: the association <code>Class.superClass</code> now
points to at most one <code>Class</code>, instead of many.
</p>

<p>
The general format of a MEL file is as follows:
</p>

<div class="org-src-container">
<pre class="src src-mel"><span class="org-keyword">import</span> <span class="org-comment-delimiter">/* </span><span class="org-comment">metamodel imports */</span>

<span class="org-keyword">define</span> <span class="org-comment-delimiter">/* </span><span class="org-comment">extension name */</span> <span class="org-keyword">extending</span> <span class="org-comment-delimiter">/* </span><span class="org-comment">input metamodels */</span> {
  <span class="org-comment-delimiter">/* </span><span class="org-comment">extensions */</span>
}
</pre>
</div>

<p>
In the <code>import</code> clause, the metamodels are imported by their namespace URI (a
string) and given an alias:
</p>

<div class="verbatim">
<p>
<b>import</b> <i>alias</i> <b>from</b> <i>namespace-uri</i>
</p>

</div>

<p>
The alias is used when defining the extension: after the <code>extending</code> keyword,
and for giving the full qualified name to classes.
</p>

<p>
The extensions supported by MEL are:
</p>

<dl class="org-dl">
<dt><code>add class</code></dt><dd><p>
Adds a new virtual class to the viewpoint.
</p>

<p>
The new class can extend or generalize any number of classes via the
optional keywords <b>specializing</b> and <b>supertyping</b>.  Note that specialized
or generalized classes may also be virtual classes defined in the current
extension.
</p>

<div class="VERBATIM">
<p>
<b>add class</b> <i>name</i> <b>specializing</b> <i>classes&#x2026;</i> <b>supertyping</b> <i>classes&#x2026;</i>
</p>

</div></dd>

<dt><code>modify class</code></dt><dd><p>
Open a block to modify the properties or associations of a
given class (which may be one created by <code>add class</code>).
</p>

<div class="VERBATIM">
<p>
<b>modify class</b> <i>name</i> { <i>class-modifications</i> }
</p>

</div>

<p>
The class modifications are:
</p>

<dl class="org-dl">
<dt><code>add property</code></dt><dd><p>
Adds a property to that class.
</p>

<div class="VERBATIM">
<p>
<b>add property</b> <i>name</i> : <i>type</i> <i>cardinality</i>
</p>

</div>

<p>
The name and type are mandatory.  The type should be one the basic
Ecore type (EString, EInt, etc.).
</p>

<p>
The cardinality is optional and defaults to 1 (meaning the property
always has a value).
</p></dd>

<dt><code>add association</code> <a id="orgd88f14c"></a></dt><dd><p>
Adds an association to that class.
</p>

<div class="VERBATIM">
<p>
<b>add association</b> <i>name</i> : <i>type</i> <i>cardinality</i>
</p>

</div>

<p>
The name and type are mandatory.  The type should be the name of a
class (which may be one created by <code>add class</code>).
</p>

<p>
The cardinality is optional and its syntax is:
</p>

<div class="VERBATIM">
<p>
(0|1|*)..(0|1|*)
</p>

</div>

<p>
You can create a <i>composition</i> relationship instead with the syntax:
</p>

<div class="VERBATIM">
<p>
<b>add composition</b> <i>name</i> : <i>type</i> <i>cardinality</i>
</p>

</div></dd>

<dt><code>modify property</code></dt><dd><p>
Modify an existing property of that class.
</p>

<div class="VERBATIM">
<p>
<b>modify property</b> <i>name</i> { <i>fields</i> }
</p>

</div>

<p>
The name is mandatory.  The allowed fields are:
</p>

<dl class="org-dl">
<dt><code>name</code></dt><dd>the property name</dd>
<dt><code>type</code></dt><dd>the property type (any Ecore data type)</dd>
<dt><code>cardinality</code></dt><dd>the property cardinality (<code>0</code> or <code>1</code>)</dd>
</dl>

<p>
Note that you cannot modify the property of a class created by <code>add
          property</code>.  You should set the correct fields in the <code>add property</code>
clause instead.
</p></dd>

<dt><code>modify association</code></dt><dd><p>
Modify an existing association of that class.
</p>

<div class="VERBATIM">
<p>
<b>modify association</b> <i>name</i> { <i>fields</i> }
</p>

</div>

<p>
The name is mandatory.  The allowed fields are:
</p>

<dl class="org-dl">
<dt><code>name</code></dt><dd>the reference name</dd>
<dt><code>type</code></dt><dd>the reference type (any class, including ones created by
<code>add class</code>)</dd>
<dt><code>cardinality</code></dt><dd>the reference cardinality (see <a href="#orgd88f14c"><code>add association</code></a>)</dd>
<dt><code>relation-type</code></dt><dd>whether the property is an <code>association</code> or a <code>composition</code></dd>
</dl>

<p>
Note that you cannot modify the reference of a class created by <code>add
          association</code> or <code>add composition</code>.  You should set the correct fields
in the <code>add association</code> (or <code>add composition</code>) clause instead.
</p></dd>

<dt><code>filter property</code></dt><dd><p>
Remove a property from that class.
</p>

<p>
The target property will not appear in the viewpoint created by this
extension.
</p>

<div class="VERBATIM">
<p>
<b>filter property</b> <i>name</i>
</p>

</div>

<p>
The name is mandatory.
</p>

<p>
Note that you cannot filter a property of a class created by <code>add
          property</code>.  You should just remove the <code>add property</code> clause instead.
</p></dd>
</dl></dd>

<dt><code>filter class</code></dt><dd><p>
Hide a class from the viewpoint.
</p>

<p>
The target class will not appear in the viewpoint created by this
extension.
</p>

<div class="VERBATIM">
<p>
<b>filter class</b> <i>name</i>
</p>

</div>

<p>
The name is mandatory, and cannot be the name of class created by <code>add
     class</code>.
</p></dd>
</dl>

<p>
Here is an example of a (nonsensical) MEL program showing most of the
constructs above:
</p>

<div class="org-src-container">
<pre class="src src-mel"><span class="org-keyword">import</span> uml <span class="org-keyword">from</span> <span class="org-string">'http://www.eclipse.org/uml2/5.0.0/UML'</span>
<span class="org-keyword">import</span> bpmn <span class="org-keyword">from</span> <span class="org-string">'http://www.omg.org/spec/BPMN/20100524/MODEL-XMI'</span>

<span class="org-keyword">define</span> extension1 <span class="org-keyword">extending</span> mm {
  <span class="org-keyword">add</span> <span class="org-keyword">class</span> X
  <span class="org-keyword">add</span> <span class="org-keyword">class</span> Y <span class="org-keyword">specializing</span> uml.Class, uml.Abstraction
  <span class="org-keyword">add</span> <span class="org-keyword">class</span> Z <span class="org-keyword">supertyping</span> uml.Activity, uml.Action, X
  <span class="org-keyword">add</span> <span class="org-keyword">class</span> B <span class="org-keyword">specializing</span> Y <span class="org-keyword">supertyping</span> Z

  <span class="org-keyword">modify</span> <span class="org-keyword">class</span> X {
    <span class="org-keyword">add</span> <span class="org-keyword">property</span> foo : EString 0
    <span class="org-keyword">add</span> composition ref : X 1..1
    <span class="org-keyword">add</span> <span class="org-keyword">association</span> ref : X 1..1
  }

  <span class="org-keyword">modify</span> <span class="org-keyword">class</span> uml.Class {
    <span class="org-keyword">add</span> <span class="org-keyword">property</span> opt : EString 0
    <span class="org-keyword">add</span> <span class="org-keyword">property</span> nonOpt : EString 1
    <span class="org-keyword">add</span> composition refC : Y 0..*
    <span class="org-keyword">add</span> <span class="org-keyword">association</span> ref : uml.Action 1..*
  }

  <span class="org-keyword">modify</span> <span class="org-keyword">class</span> bpmn.Activity {
    <span class="org-keyword">modify</span> <span class="org-keyword">association</span> default {
      <span class="org-keyword">name</span> defaultRenamed
      <span class="org-keyword">type</span> X
      <span class="org-keyword">cardinality</span> 0..*
      relation-<span class="org-keyword">type</span> <span class="org-keyword">association</span>
    }
  }

  <span class="org-keyword">modify</span> <span class="org-keyword">class</span> uml.Behavior {
    <span class="org-keyword">modify</span> <span class="org-keyword">property</span> isReentrant {
      <span class="org-keyword">type</span> EString
      <span class="org-keyword">cardinality</span> 0
    }
    <span class="org-keyword">filter</span> <span class="org-keyword">property</span> isReentrant
  }

  <span class="org-keyword">modify</span> <span class="org-keyword">class</span> uml.Activity {
    <span class="org-keyword">modify</span> <span class="org-keyword">property</span> isReadOnly {
      <span class="org-keyword">type</span> EBoolean
      <span class="org-keyword">cardinality</span> 0
    }
  }
  <span class="org-comment-delimiter">// </span><span class="org-comment">a comment</span>
  <span class="org-keyword">filter</span> <span class="org-keyword">class</span> uml.DataType
}
</pre>
</div>

<p>
The following diagrams outline the MEL grammar; the <a href="https://raw.githubusercontent.com/atlanmod/emfviews/master/dsls/mel/org.atlanmod.emfviews.mel/src/org/atlanmod/emfviews/mel/Mel.xtext">full Xtext grammar</a> can be
found in the source code.
</p>


<div class="figure">
<p><img src="images/mel-grammar1.svg" class="no-shadow"/>
</p>
<p><span class="figure-number">Figure 15: </span>Overview diagram of MEL grammar</p>
</div>


<div class="figure">
<p><img src="images/mel-grammar2.svg" class="no-shadow"/>
</p>
<p><span class="figure-number">Figure 16: </span>MEL grammar fragment diagram for clauses in the body of <code>modify class</code></p>
</div>


<h4 id="java-api"><a href="#java-api">Java API</a></h4>
<p>
You can construct <code>View</code> and <code>Viewpoint</code> classes directly by invoking their
constructors:
</p>

<div class="org-src-container">
<pre class="src src-java">Viewpoint(<span class="org-type">List</span>&lt;<span class="org-type">EPackage</span>&gt; <span class="org-variable-name">metamodels</span>)
Viewpoint(<span class="org-type">List</span>&lt;<span class="org-type">EPackage</span>&gt; <span class="org-variable-name">metamodels</span>, <span class="org-type">WeavingModel</span> <span class="org-variable-name">wm</span>)

View(<span class="org-type">Viewpoint</span> <span class="org-variable-name">v</span>, <span class="org-type">List</span>&lt;<span class="org-type">Resource</span>&gt; <span class="org-variable-name">models</span>)
View(<span class="org-type">Viewpoint</span> <span class="org-variable-name">v</span>, <span class="org-type">List</span>&lt;<span class="org-type">Resource</span>&gt; <span class="org-variable-name">models</span>, <span class="org-type">WeavingModel</span> <span class="org-variable-name">wm</span>)
</pre>
</div>

<p>
If the weaving model argument is not specified, an empty weaving model is used
instead (see <code>Viewpoint.emptyWeavingModel</code>).
</p>

<p>
You can browse the content of the viewpoint using <code>Viewpoint.getRootPackage</code>,
and the content of the view using <code>View.getVirtualContents</code>.
</p>

<p>
Finally, you may also associate these objects to resources, should you want to
serialize them into files:
</p>

<div class="org-src-container">
<pre class="src src-java"><span class="org-type">ViewpointResource</span> <span class="org-variable-name">vpr</span> = <span class="org-keyword">new</span> <span class="org-type">ViewpointResource</span>(<span class="org-string">"my.eviewpoint"</span>);
vpr.setResource(viewpoint);
vpr.save(<span class="org-constant">null</span>);

<span class="org-type">ViewResource</span> <span class="org-variable-name">vr</span> = <span class="org-keyword">new</span> <span class="org-type">ViewResource</span>(<span class="org-string">"my.eview"</span>);
viewResource.setView(view);
viewResource.save(<span class="org-constant">null</span>);
</pre>
</div>

<p>
This will save the viewpoint and views to their corresponding files.
</p>

<p>
See <a href="#creating-a-view-programmatically">Creating a view programmatically</a> for a guided example on how to use the API.
</p>


<h3 id="weaving-models"><a href="#weaving-models">Weaving models</a></h3>
<p>
Weaving models describe what elements are put into viewpoints and views.  The
following gives the metamodel of weaving models as a class diagram:
</p>


<div class="figure">
<p><img src="images/weavingmodel-metamodel.svg" class="no-shadow"/>
</p>
</div>

<p>
We following subsections describe the role of each element.  Note that, as
weaving models can be used at the metamodel and model levels for building
viewpoints and views (respectively), the following description applies to both
levels, even though we only use the terms &ldquo;models&rdquo; and &ldquo;views&rdquo;.  For elements
that are handled differently by viewpoints and views, we make the distinction
explicit.
</p>


<h4 id="weaving-model"><a href="#weaving-model">Weaving model</a></h4>
<p>
The <code>WeavingModel</code> is the root model element.
</p>

<p>
It contains the contributing models and the virtual links, which are
modifications made to the models that only appear in the view.
</p>

<p>
Its <code>name</code> attribute is used as part of the viewpoint&rsquo;s namespace URI.  Views do
not make use of the <code>name</code> attribute.
</p>

<p>
The <code>whitelist</code> flag changes the meaning of the filters.  If the <code>whitelist</code>
flag is false (the default), then the view will include all the elements of
contributing models, unless they are explicitly filtered out.  If the
<code>whitelist</code> flag is true, then the view will include no element, unless they are
explicitly filtered in.
</p>


<h4 id="contributing-model"><a href="#contributing-model">Contributing model</a></h4>
<p>
A <code>ContributingModel</code> is a model included in the view.
</p>

<p>
The purpose of this class is to hold the concrete elements that are
targeted by virtual links.
</p>

<p>
<code>URI</code> always refers to the metamodel namespace URI, both for viewpoint and
view weaving models.
</p>


<h4 id="concrete-element"><a href="#concrete-element">Concrete element</a></h4>
<p>
A <code>ConcreteElement</code> is an element of a contributing model.
</p>

<p>
For viewpoints, <code>path</code> is the fully qualified name to the element (not including
the metamodel name, since that&rsquo;s already given by its container
<code>ContributingModel</code>).  E.g., <code>Component.name</code> would point to the <code>name</code>
attribute of the <code>Component</code> class in a given metamodel.
</p>

<p>
For views, <code>path</code> is the URI returned by <code>Resource.getURIFragment</code>.
</p>

<p>
A concrete element can further be of two subtypes: <code>ConcreteConcept</code> and
<code>ConcreteAssociation</code>.  This distinction is useful for virtual links other than
filters, where for example the opposite to a virtual associations can only be an
association, not just any element.
</p>


<h4 id="virtual-link"><a href="#virtual-link">Virtual link</a></h4>
<p>
<code>VirtualLink</code> is the parent class for all modifications made to the model.
</p>

<p>
All modifications have a name, which is used for the virtual feature name,
except for the <code>Filter</code> class where the name is ignored.
</p>


<h4 id="filter"><a href="#filter">Filter</a></h4>
<p>
A <code>Filter</code>, depending on the value of <code>WeavingModel.whitelist</code>, includes or
excludes an element from the contributing models.
</p>

<p>
It can only refer to <code>ConcreteElements</code>.
</p>

<p>
In views, the <code>whitelist</code> flag is always taken to be false.  That is, filtered
elements are always filtered <i>out</i>.  In addition, as filtering individual view
elements comes with a performance cost, it is preferable to filter whole
features or classes in the viewpoint instead.
</p>


<h4 id="virtual-association"><a href="#virtual-association">Virtual association</a></h4>
<p>
A <code>VirtualAssociation</code> is an association that exists only in the view.
</p>

<p>
It has <code>source</code> and a <code>target</code>, which can be concrete or virtual concepts.
Thus, you may create a virtual association between one class of a contributing
metamodel and a virtual class that only exists in the view.
</p>

<p>
The <code>lowerBound</code> and <code>upperBound</code> properties determine the cardinality of the
association, just like in Ecore metamodels.  If the <code>composition</code> flag is true,
the virtual association is a containment.  A virtual association can have one
opposite association (virtual or not), given by the <code>opposite</code> reference.
</p>


<h4 id="virtual-concept"><a href="#virtual-concept">Virtual concept</a></h4>
<p>
A <code>VirtualConcept</code> is a concept that exists only in the view.
</p>

<p>
It can subclass or superclass other concepts (virtual or not).
</p>


<h4 id="virtual-property"><a href="#virtual-property">Virtual property</a></h4>
<p>
A <code>VirtualProperty</code> is a property that exists only in the view.
</p>

<p>
It must attach to a <code>parent</code> concept (virtual or not).  The <code>optional</code> flag
determines its cardinality (1 if <code>false</code> and <code>0..1</code> if true).  The <code>type</code>
attribute describes the primitive type of the property.  The following types are
supported:
</p>

<pre class="example">
boolean
byte
char
double
float
int
long
short
Date
String
</pre>


<h3 id="matching-models"><a href="#matching-models">Matching models</a></h3>
<p>
A matching model is a more declarative way to create a weaving model for views.
Its main purpose is to populate virtual associations based on the content of
the contributing models.
</p>

<p>
In the current implementation, EMF Views can use ECL files to create weaving
models.  Such files contain one rule for each virtual association.  Here is one
ECL file with two rules:
</p>

<div class="org-src-container">
<pre class="src src-ecl"><span class="org-keyword">rule</span> detailedProcess
<span class="org-keyword">match</span> s : ea!Process
<span class="org-keyword">with</span>  t : bpmn!Process
{
  <span class="org-keyword">compare</span>
  {
    <span class="org-keyword">return</span> s.name = t.name;
  }
}

<span class="org-keyword">rule</span> detailedRequirement
<span class="org-keyword">match</span> s : ea!Requirement
<span class="org-keyword">with</span>  t : reqif!SpecObject
{
  <span class="org-keyword">compare</span>
  {
    <span class="org-keyword">return</span> t.values.exists(v | v.theValue = <span class="org-string">"s.name"</span>);
  }
}
</pre>
</div>

<p>
See the <a href="https://www.eclipse.org/epsilon/doc/ecl/">ECL documentation</a> for a full syntactic account of the language.
</p>

<p>
Each rule is used to match the two models it refers to.  If the predicate inside
the <code>compare</code> clause is true for two model elements, then a virtual association
(of the same as the rule&rsquo;s) will contain an entry for these two elements in the
created weaving model.
</p>

<p>
Here for example the rule <code>detailedProcess</code> will match whenever a model element
of the <code>ea!Process</code> class and a model of the <code>bpmn!Process</code> class both have the
exact same name.  These classes belong respectively to the TOGAF &rsquo;content
framework&rsquo; and BPMN metamodels, as specified by the <code>contributingMetamodels</code>
line in an accompanying <code>eviewpoint</code> file.  If two elements match, the resulting
weaving model will contain an entry in the virtual association <code>detailedProcess</code>
from the source element (an <code>ea!Process</code>) to the target element (a
<code>bpmn!Process</code>).
</p>

<p>
This virtual association is then used to populate the view by the <code>View</code> class.
</p>


<h4 id="adding-new-matching-models"><a href="#adding-new-matching-models">Adding new matching models</a></h4>
<p>
You can add new matching engines through the
<code>org.atlanmod.emfviews.virtuallinks.delegator</code> extension point.  It takes a file
extension (e.g., &ldquo;ecl&rdquo;) and a class implementing the <code>IVirtualLinksDelegate</code>
interface, which has a single method:
</p>

<div class="org-src-container">
<pre class="src src-java"><span class="org-type">WeavingModel</span> <span class="org-function-name">createWeavingModel</span>(<span class="org-type">URI</span> <span class="org-variable-name">linksDslFile</span>,
                                <span class="org-type">Map</span>&lt;<span class="org-type">String</span>, <span class="org-type">Resource</span>&gt; <span class="org-variable-name">inputModels</span>)
</pre>
</div>

<p>
You can look at <a href="https://github.com/atlanmod/emfviews/blob/master/plugins/org.atlanmod.emfviews.virtuallinksepsilondelegate/src/org/atlanmod/emfviews/virtuallinksepsilondelegate/EclDelegate.java"><code>EclDelegate</code></a> for an example implementation of this interface.
</p>
</div>
</body>
</html>
