<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>EMF Views User Guide</title>
<meta name="generator" content="Org mode">
<meta name="author" content="root">
<link rel="stylesheet" href="style.css">
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2018 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">EMF Views User Guide</h1>
<div id="table-of-contents">
<h2>EMF Views User Guide</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org2cd516c">Overview</a></li>
<li><a href="#orgc6a8a8c">Tutorials</a>
<ul>
<li><a href="#org3683e2a">Creating a view manually</a></li>
<li><a href="#orgc0e03cf">Creating a view with VPDL</a>
<ul>
<li><a href="#org760ba75">Writing a VPDL file</a></li>
<li><a href="#orgaeb38cf">Using a VPDL file in Eclipse</a></li>
</ul>
</li>
<li><a href="#org2d36e57">Creating a view programmatically</a>
<ul>
<li><a href="#orgf0876ac">Caveats</a></li>
<li><a href="#org2cce758">Creating a weaving model programmatically</a></li>
</ul>
</li>
<li><a href="#org3d75320">Querying a view with OCL</a>
<ul>
<li><a href="#org0926820">Programmatic OCL queries</a></li>
</ul>
</li>
<li><a href="#org8489b14">Transforming a view with ATL</a></li>
</ul>
</li>
<li><a href="#org911f998">Concepts</a>
<ul>
<li><a href="#org1ca3f19">Views</a>
<ul>
<li><a href="#org6853c8a">eview and eviewpoint files</a></li>
<li><a href="#org6cc3124">VPDL</a></li>
<li><a href="#orge295c2f">Java API</a></li>
</ul>
</li>
<li><a href="#org87f9f05">Weaving models</a>
<ul>
<li><a href="#org818057d">Weaving model</a></li>
<li><a href="#org37100a1">Contributing model</a></li>
<li><a href="#orge9b9f0b">Concrete element</a></li>
<li><a href="#orgabeda4e">Virtual link</a></li>
<li><a href="#org64e626d">Filter</a></li>
<li><a href="#org6fd68a2">Virtual association</a></li>
<li><a href="#org25bd3e7">Virtual concept</a></li>
<li><a href="#org4b2600d">Virtual property</a></li>
</ul>
</li>
<li><a href="#org2dde80d">Matching models</a>
<ul>
<li><a href="#org20f4228">Adding new matching models</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org2cd516c" class="outline-2">
<h2 id="org2cd516c">Overview</h2>
<div class="outline-text-2" id="text-org2cd516c">
<p>
EMF Views is a tool that enables to combine and refine/augment several EMF-based
models into <i>views</i>.  These views behave as regular models: you can navigate,
query and transform them as you would do with any regular model.  This comes in
handy when you want to deal with several related models, for instance.
</p>

<p>
Views can filter any element from its contributing models.  This can be used to
create views focused on particular aspects of related models.  Filters also
enable a form of access control: one can create views that hide sensitive
information coming from one or more models.
</p>

<p>
Views can also augment the contributing models with new elements, attributes or
associations.  This is useful for instance when combining related models: you
can add new associations that link related classes together, allowing you to
navigate or query the view more naturally.
</p>

<p>
Views can be created interactively via <code>eview</code> and <code>eviewpoint</code> definition
files, or can be created programmatically.  Moreover, EMF Views currently comes
with two DSLs that ease the definition of views: <a href="#org6cc3124">VPDL</a> and MEL.
</p>
</div>
</div>

<div id="outline-container-orgc6a8a8c" class="outline-2">
<h2 id="orgc6a8a8c">Tutorials</h2>
<div class="outline-text-2" id="text-orgc6a8a8c">
<p>
These tutorials will take you through the main features of EMF Views.
</p>
</div>

<div id="outline-container-org3683e2a" class="outline-3">
<h3 id="org3683e2a">Creating a view manually</h3>
<div class="outline-text-3" id="text-org3683e2a">
<p>
We will create a view linking two related models representing books.
</p>

<p>
In order to create a view, you need the following:
</p>

<ol class="org-ol">
<li>Metamodels.  These can be given as Ecore files, or through the namespace URI
if the packages are loaded as plugins.</li>
<li>Models.  These can be given in any serialization format supported by EMF
(usually XMI).</li>
<li>A <i>viewpoint</i>.  This defines the metamodel of the view.  It is specified
through an <code>eviewpoint</code> file.</li>
<li>An <code>eview</code> file which describes the view.</li>
</ol>

<p>
First, unpack the <code>emfviews-tutorial</code> example.  Here is what the file hierarchy
should look like:
</p>

<pre class="example">
.
├── metamodels
│   ├── Book.ecore
│   └── Publication.ecore
├── models
│   ├── book.xmi
│   └── publication.xmi
├── viewpoints
│   ├── publicationsAndBooks.eviewpoint
│   └── publicationsAndBooks.xmi
└── views
    ├── allChapters.ecl
    ├── allChapters.eview
    ├── firstChapter.ecl
    └── firstChapter.eview
</pre>

<p>
This is one common way to organize views that are created using files, but it is not mandatory to follow this structure.
</p>

<p>
The <code>metamodels</code> folder contains the Ecore files for our two metamodels, Book
and Publication.
</p>


<div class="figure">
<p><img src="images/metamodels.png" alt="metamodels.png">
</p>
</div>

<p>
The Book metamodel has details about each chapter, while the Publication has
more information about the publisher and publishing date.  This is a simple
example of two metamodels with overlapping and complementary information.  The
view we will create will bring all this information under a single (virtual)
metamodel.
</p>

<p>
The <code>models</code> folder contains two serialized models in XMI format that conform to
these metamodels.  Here are the contents of <code>book.xmi</code> (left) and
<code>publication.xmi</code> (right):
</p>


<div class="figure">
<p><img src="images/models.png" alt="models.png">
</p>
</div>

<p>
They both model the same book.  In this example, there is only one
element for simplicity.  In realistic situation, each model may contain several
books or publications.  Our view will work the same with any number of elements.
</p>

<p>
To define the view, we must first define a viewpoint, which acts as a (virtual)
metamodel for the view.  Let us look at the file hierarchy again:
</p>

<pre class="example">
├── viewpoints
│   ├── publicationsAndBooks.eviewpoint
│   └── publicationsAndBooks.xmi
</pre>

<p>
The <code>viewpoints</code> folder contains two files.  Let us focus on the
<code>publicationsAndBooks.eviewpoint</code> file which defines the viewpoint, and is
defined as:
</p>

<pre class="example">
contributingMetamodels=../metamodels/Publication.ecore,\
		       ../metamodels/Book.ecore
weavingModel=publicationsAndBooks.xmi
</pre>

<p>
(See <a href="#org6853c8a">eview and eviewpoint files</a> for the full syntax and valid configuration
keys of <code>eviewpoint</code> files.)
</p>

<p>
The first two lines list the <i>contributing metamodels</i>.  These are the two
metamodels we are concerned with.  In this case, we give relative URIs to the
Ecore files in the <code>metamodels</code> folder.
</p>

<div class="note">
<p>
We could also have used namespace URIs in <code>contributingModels</code>.  The upside of
pointing to the Ecore files in this case is that EMF Views will load them
without us having to register the EPackages manually.
</p>

</div>

<p>
The third line specifies the <a href="#org87f9f05"><i>weaving model</i></a>.  The weaving model describes how
the viewpoint is constructed: it contains filters that select or exclude
elements from the contributing metamodels, and it describes new elements that
are to be added to the viewpoint.  If you omit the <code>weavingModel</code> property, no
elements are filtered or added.
</p>

<p>
Let&rsquo;s try it now.  Remove or comment (<code>#</code> begins a line comment) the
<code>weavingModel</code> line, then save the file.  You have to open the viewpoint in text
mode (Right click &rarr; <code>Open With</code> &rarr; <code>Text Editor</code>).
</p>

<p>
After you have made the change, you want to open the <code>eviewpoint</code> file in a
model editor.  The Sample Ecore Model Editor and the <a href="https://help.eclipse.org/oxygen/topic/org.eclipse.modisco.infrastructure.doc/mediawiki/model_browser/user.html">MoDisco Model Browser</a>
should both be able to do so.  Right click &rarr; <code>Open With</code> &rarr; <code>Other...</code>, and
in the dialog select <code>Sample Ecore Model Editor</code> then click OK:
</p>


<div class="figure">
<p><img src="images/editor-select.png" alt="editor-select.png">
</p>
</div>

<p>
Here is what you should see:
</p>


<div class="figure">
<p><img src="images/viewpoint-empty-weaving.png" alt="viewpoint-empty-weaving.png">
</p>
</div>

<p>
This metamodel combines, under the same <code>viewpoint</code> package, our two metamodels
Publication and Book.  This metamodel is purely virtual: the packages
Publication and Book, and all their elements, are proxies to the actual elements
from the contributing metamodels.
</p>

<p>
Note that the <code>Publication</code> package comes before <code>Book</code> because that is the
order we specified in the <code>contributingMetamodels</code> line in the <code>eviewpoint</code> file.
</p>

<p>
Let us restore the <code>weavingModel</code> line.  First, close the Sample Ecore Model
Editor view of the <code>eviewpoint</code>.  Then, restore or uncomment the <code>weavingModel</code>
line in the <code>eviewpoint</code> by opening it with the Text Editor (or reuse the Text
Editor tab if you had not closed it).  Save the <code>eviewpoint</code> file, and open it
up with the Sample Ecore Model Editor once more.
</p>

<p>
Here is what you should get now:
</p>


<div class="figure">
<p><img src="images/viewpoint.png" alt="viewpoint.png">
</p>
</div>

<p>
There are two differences with the previous viewpoint: there is a new
<code>bookChapters</code> association in the <code>Publication</code> class, and the <code>Chapter.nbPages</code>
attribute has been filtered out.  The <code>bookChapters</code> association enhances the
Publication metamodel by allowing us to navigate the chapters from a
<code>Publication</code> instance.  A <code>Publication</code> in this viewpoint would have all the
information of the <code>Book</code> instance, and more.
</p>

<p>
Note that the <code>Chapter</code> class is part of the <code>Book</code> package (it comes from the
Book metamodel), but it is the target class of an association of the
<code>Publication</code> package.  Combining both metamodels in the viewpoint allows us to
create inter-metamodel associations, since they are now part of the same virtual
metamodel.
</p>

<p>
If we open the weaving model <code>publicationsAndBooks.xmi</code> with the Sample Ecore
Model Editor, we can see that it contains exactly these two changes.  Here is
the viewpoint on the left with the weaving model on the right.  The changes made
by the weaving model to the viewpoint are highlighted:
</p>


<div class="figure">
<p><img src="images/viewpoint-and-weaving.png" alt="viewpoint-and-weaving.png">
</p>
</div>

<p>
Now that we have a viewpoint, all that is left is the view itself.  Let us take
another look at the file hierarchy:
</p>

<pre class="example">
└── views
    ├── allChapters.ecl
    ├── allChapters.eview
    ├── firstChapter.ecl
    └── firstChapter.eview
</pre>

<p>
In the <code>views</code> folder, two views are defined: <code>allChapters</code> and <code>firstChapter</code>.
Let us focus on <code>allChapters</code> for now.  If we look inside <code>allChapters.eview</code>:
</p>

<pre class="example">
contributingModels=../models/publication.xmi,../models/book.xmi
viewpoint=../viewpoints/publicationsAndBooks.eviewpoint
matchingModel=allChapters.ecl
</pre>

<p>
(Again, see <a href="#org6853c8a">eview and eviewpoint files</a> for a complete description of <code>eview</code>
files.)
</p>

<p>
The <code>contributingModels</code> line point to the model resources which contribute to
the view.  Note that the order of the contributing models does not have to match
the order of the <code>contributingMetamodels</code> line in the <code>eviewpoint</code> file.
</p>

<p>
The <code>viewpoint</code> line is a relative path to the <code>eviewpoint</code> file.  In order to
define a view, we need to give it a metamodel, which is a viewpoint.
</p>

<p>
Finally, the <code>matchingModel</code> line is a path to an Epsilon Comparison file.  The
matching model contains rules that are used by EMF Views to construct a weaving
model for the view.
</p>

<div class="note">
<p>
EMF Views can be extended to use other matching models beyond ECL.  See <a href="#org20f4228">Adding
new matching models</a>.
</p>

<p>
Instead of a matching model, you can specify a weaving model directly in the
<code>eview</code> file.  Although the weaving model is usually too tedious to create
manually, it may be a better option when creating views programmatically.
</p>

</div>

<p>
Let us look at this ECL file now:
</p>

<div class="org-src-container">
<pre class="src src-ecl"><span class="org-comment-delimiter">//</span><span class="org-comment">alias_publication=http://publication</span>
<span class="org-comment-delimiter">//</span><span class="org-comment">alias_book=http://book</span>

<span class="org-keyword">rule</span> bookChapters
<span class="org-keyword">match</span> p : publication!Publication
<span class="org-keyword">with</span>  c : book!Chapter
{
  <span class="org-keyword">compare</span>
  {
    <span class="org-keyword">return</span> p.title = c.eContainer().title
       <span class="org-keyword">and</span> p.author = c.eContainer().authorName;
  }
}
</pre>
</div>

<p>
It describes a rule to populate the virtual association <code>bookChapters</code>.  It
considers each publication <code>p</code> from the (concrete) Publication metamodel against
each chapter of the (concrete) Book metamodel; in other words, a Cartesian
product Publication &times; Book.  For each pair <code>(p,c)</code>, if the predicate in
<code>compare</code> is true, then the matching elements are part of the association
<code>bookChapters</code>.
</p>

<p>
Here, if we have a book and a publication that refer to the same ouvrage, then
we want to add all chapters of the book to the association.  Thus, the predicate
checks that the title of the publication is the same as the book&rsquo;s title, and
that they both have the same author, since that is all the common information
between the two metamodels.
</p>

<p>
Note that for our two particular models which describe the same book, the
predicate will always return true.  Hence, we could have written the rule
trivially:
</p>

<div class="org-src-container">
<pre class="src src-ecl">...
  <span class="org-keyword">compare</span>
  {
    <span class="org-keyword">return</span> true;
  }
}
</pre>
</div>

<p>
But the former version will work with models containing more books and
publications.
</p>

<p>
When we open the <code>allChapters.eview</code> file with the MoDisco Model Browser (Right
click &rarr; <code>Open With</code> &rarr; <code>Other...</code>, and select MoDisco Model Browser then
click OK), we can see that the <code>bookChapters</code> associations allows us to navigate
the chapters from the Book model:
</p>


<div class="figure">
<p><img src="images/model-modisco.png" alt="model-modisco.png">
</p>
</div>

<p>
We also can see that the <code>nbPages</code> attribute is absent from the chapters,
because it has been filtered out from the metamodel.
</p>

<p>
Now, we have defined a view that combines the Book and Publication models.  But
we can define multiple views for the same viewpoint.  Take a look at
<code>firstChapter.eview</code>:
</p>

<pre class="example">
contributingModels=../models/publication.xmi,../models/book.xmi
viewpoint=../viewpoints/publicationsAndBooks.eviewpoint
matchingModel=firstChapter.ecl
</pre>

<p>
The only difference with <code>allChapters.eview</code> is the matching model.  For this
view, we want only the <i>first</i> chapter of a matching book to be added to the new
<code>bookChapters</code> association.  Consequently, in <code>firstChapter.ecl</code>, the predicate
is:
</p>

<div class="org-src-container">
<pre class="src src-ecl" id="org6395740"><span class="org-keyword">return</span> p.title = c.eContainer().title
   <span class="org-keyword">and</span> c = c.eContainer().eContents().first();
</pre>
</div>

<p>
The right-hand part of the condition only matches if the chapter <code>c</code> is the
first one of the book it is part of.
</p>

<p>
As a result, when we open <code>firstChapter.eview</code> with the MoDisco Model Browser,
only one chapter is part of the <code>bookChapters</code> association:
</p>


<div id="org0c0c535" class="figure">
<p><img src="images/view-first-chapter.png" alt="view-first-chapter.png">
</p>
</div>

<p>
And that&rsquo;s it!  We have created one viewpoint combining two metamodels, then we
created two views combining two models using this viewpoint.  Note that while
this method of creating views with <code>eviewpoint</code> and <code>eview</code> files is suitable
for creating small-scale views interactively, EMF Views offers two other methods
to create views: programmatically and using VPDL.
</p>

<p>
In the next two sections, we will show how we can filter other elements in the
viewpoint, and how we can add new virtual elements.
</p>
</div>
</div>

<div id="outline-container-orgc0e03cf" class="outline-3">
<h3 id="orgc0e03cf">Creating a view with VPDL</h3>
<div class="outline-text-3" id="text-orgc0e03cf">
</div>
<div id="outline-container-org760ba75" class="outline-4">
<h4 id="org760ba75">Writing a VPDL file</h4>
<div class="outline-text-4" id="text-org760ba75">
<p>
VPDL, standing for <i>ViewPoint Description Language</i>, is a domain-specific
language for easing the specification of viewpoints and the creation of
corresponding views using EMF Views.  The syntax of VPDL is inspired by SQL&rsquo;s
<code>SELECT</code> statement.
</p>

<div class="note">
<p>
The VPDL syntax is still experimental and likely to change in the near future.
</p>

</div>

<p>
Instead of manually creating <code>eviewpoint</code> and <code>eview</code> files, you write a single
<code>vpdl</code> file which describes the viewpoint and the view at the same time.  Here
is a VPDL file recreating the <code>firstChapter</code> view of the previous section:
</p>

<div class="org-src-container">
<pre class="src src-sql"><span class="org-keyword">create</span> <span class="org-keyword">view</span> <span class="org-function-name">publicationsAndBooks</span> <span class="org-keyword">as</span>

<span class="org-keyword">select</span> pub.Publication.*,
       pub.Publication <span class="org-keyword">join</span> book.Chapter <span class="org-keyword">as</span> firstChapter,
       book.Book.*,
       book.Chapter.title,

<span class="org-keyword">from</span> <span class="org-string">'http://publication'</span> <span class="org-keyword">as</span> pub,
     <span class="org-string">'http://book'</span> <span class="org-keyword">as</span> book,

<span class="org-keyword">where</span> <span class="org-string">'s.title = t.eContainer().title</span>
<span class="org-string">   and t = t.eContainer().eContents().first()'</span>
      <span class="org-keyword">for</span> firstChapter
</pre>
</div>

<p>
(See <a href="#org6cc3124">VPDL</a> for a description of the full syntax.)
</p>

<p>
The first line <code>create view</code> specifies the name of the viewpoint.  This name is
used for generating the <code>eviewpoint</code>, <code>eview</code> and <code>xmi</code> weaving model file.
</p>

<p>
With the <code>select</code> clause, you explicitly select the classes and features from
the contributing metamodels that will appear in the viewpoint.  The <code>select</code>
clause essentially specifies the viewpoint&rsquo;s weaving model, albeit in plain
text.  Here with <code>pub.Publication.*</code> we say that we want all features of the
<code>pub.Publication</code> class in the viewpoint, and by selecting only
<code>book.Chapter.title</code> from <code>book.Chapter</code>, we exclude the <code>nbPages</code> attribute.
The <code>select</code> clause is a whitelist, so if we don&rsquo;t include the <code>book.Book.*</code>
line for instance, the resulting viewpoint would not let us navigate <code>Book</code>
instances, since there would be no visible features.
</p>

<p>
The line:
</p>

<div class="org-src-container">
<pre class="src src-sql">pub.Publication <span class="org-keyword">join</span> book.Chapter <span class="org-keyword">as</span> firstChapter,
</pre>
</div>

<p>
tells EMF Views to create a virtual association from <code>Publication</code> to <code>Chapter</code>
called <code>firstChapter</code>.  This is the same as the <code>bookChapter</code> association of the
previous section.
</p>

<p>
The <code>from</code> clause simply maps the namespace URIs of the contributing metamodels
to aliases used in the <code>select</code> clause.
</p>

<p>
Lastly, the <code>where</code> clause specifies, for each new association, how to match
elements from contributing models in the view.  This is used to generate the matching model
as an ECL file.  Here, we use the same predicate as <a href="#org6395740">before</a>, but this time <code>s</code>
and <code>t</code> refer respectively to the source (<code>Publication</code>) and target (<code>Chapter</code>)
of the association.
</p>
</div>
</div>

<div id="outline-container-orgaeb38cf" class="outline-4">
<h4 id="orgaeb38cf">Using a VPDL file in Eclipse</h4>
<div class="outline-text-4" id="text-orgaeb38cf">
<p>
To use a VPDL file, your project need to be configured as an Xtext project in
Eclipse.  If you create a new project and add a <code>vpdl</code> file in it, Eclipse
should prompt you to configure it as an Xtext project.  Otherwise in the
outline, Right click on the project &rarr; <code>Configure</code> &rarr; <code>Convert to Xtext
project</code>.
</p>

<p>
Once the project is configured, whenever you save the <code>vpdl</code> file Xtext should
generate three files: the <code>eviewpoint</code>, the <code>xmi</code> weaving model, and the <code>ecl</code>
matching model.
</p>

<p>
If you unpack the <code>vpdl-tutorial</code> example, here is how the file hierarchy looks
like after we save the <code>publicationAndBooks.vpdl</code> file:
</p>

<pre class="example">
.
├── src
│   └── publicationsAndBooks.vpdl
├── src-gen
│   ├── publicationsAndBooks.ecl
│   ├── publicationsAndBooks.eviewpoint
│   └── publicationsAndBooks.xmi
└── views
    └── firstChapter.eview
</pre>

<p>
All the generated files are in the <code>src-gen</code> directory.
</p>

<p>
To create the view however, we still need an <code>eview</code> file.  VPDL does not create
one for a view (yet).  You just have to point to the generated files, and
specify the contributing models you want to use.  Here is the definition of
<code>firstChapter.eview</code>:
</p>

<div class="org-src-container">
<pre class="src src-sh"><span class="org-variable-name">viewpoint</span>=../src-gen/publicationsAndBooks.eviewpoint
<span class="org-variable-name">contributingModels</span>=../../emfviews-tutorial/models/publication.xmi,<span class="org-sh-escaped-newline">\</span>
                   ../../emfviews-tutorial/models/book.xmi
<span class="org-variable-name">matchingModel</span>=../src-gen/publicationsAndBooks.ecl
<span class="org-variable-name">weavingModel</span>=publicationAndBooks.xmi
</pre>
</div>

<p>
Opening <code>firstChapter.eview</code> using the MoDisco Model Browser, we get the same
result as <a href="#org0c0c535">before</a>, the difference being that this time the new association is
more accurately called <code>firstChapter</code>:
</p>


<div class="figure">
<p><img src="images/vpdl-view-first-chapter.png" alt="vpdl-view-first-chapter.png">
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org2d36e57" class="outline-3">
<h3 id="org2d36e57">Creating a view programmatically</h3>
<div class="outline-text-3" id="text-org2d36e57">
<p>
In some situations, you may want to create views without touching the
filesystem.  The EMF Views API lets you create views purely in memory, without
creating <code>eview</code> files or <code>vpdl</code> files.
</p>

<p>
Here is a standalone example of creating a minimal view on the <code>UMLPackage</code>
using the API:
</p>

<div class="org-src-container">
<pre class="src src-java"><span class="org-comment-delimiter">// </span><span class="org-comment">1. Create viewpoint</span>
<span class="org-type">Viewpoint</span> <span class="org-variable-name">viewpoint</span> = <span class="org-keyword">new</span> <span class="org-type">Viewpoint</span>(Arrays.asList(UMLPackage.eINSTANCE));

<span class="org-comment-delimiter">// </span><span class="org-comment">2. Create model</span>
<span class="org-type">UMLFactory</span> <span class="org-variable-name">f</span> = UMLFactory.eINSTANCE;
<span class="org-type">Component</span> <span class="org-variable-name">C1</span> = f.createComponent();
C1.setName(<span class="org-string">"Comp1"</span>);
<span class="org-type">Component</span> <span class="org-variable-name">C2</span> = f.createComponent();
C2.setName(<span class="org-string">"Comp2"</span>);

<span class="org-type">Resource</span> <span class="org-variable-name">model</span> = <span class="org-keyword">new</span> <span class="org-type">ResourceImpl</span>();
model.getContents().addAll(Arrays.asList(C1, C2));

<span class="org-comment-delimiter">// </span><span class="org-comment">3. Create view</span>
<span class="org-type">View</span> <span class="org-variable-name">view</span> = <span class="org-keyword">new</span> <span class="org-type">View</span>(viewpoint, Arrays.asList(model));

<span class="org-comment-delimiter">// </span><span class="org-comment">4. Navigate the view</span>
<span class="org-keyword">for</span> (<span class="org-type">EObject</span> <span class="org-function-name">o</span> : view.getVirtualContents()) {
  System.out.println(o.eGet(o.eClass().getEStructuralFeature(<span class="org-string">"name"</span>)));
}
</pre>
</div>

<p>
To create a <code>Viewpoint</code>, we must provide a list of contributing metamodels as
instances of <code>EPackage</code>; here we give the <code>UMLPackage</code> metamodel.  We do not
provide a weaving model, so a default empty weaving model is used instead.  With
an empty weaving model, no elements are filtered out from the contributing
metamodels, and no new elements are added.
</p>

<p>
Then we build the model using the <code>UMLFactory</code>.  We keep it simple for the
purposes of example: just two <code>Component</code> instances.  In a realistic situation,
this model could come from anywhere, as long as we have a resource to provide to
the <code>View</code> constructor.
</p>

<p>
The third step is to create the view by passing the viewpoint and a list of
contributing models as instances of <code>Resource</code> to <code>View</code>.  Here we pass the
model resource we just constructed.  The third optional argument to the <code>View</code>
constructor is the view weaving model.  As for <code>Viewpoint</code>, an empty weaving
model is used if unspecified.
</p>

<p>
Finally, we navigate the view to print the name of the components inside it.
Since we have used empty weaving models, the view is identical in content to the
model.  Running this snippet will output the names of the two components:
</p>

<pre class="example">
Comp1
Comp2
</pre>
</div>

<div id="outline-container-orgf0876ac" class="outline-4">
<h4 id="orgf0876ac">Caveats</h4>
<div class="outline-text-4" id="text-orgf0876ac">
<p>
Note that we <i>have</i> to use the reflective EMF API when navigating views, because
there is no corresponding generated code.  View elements are always dynamic
objects.  In other words, it would be tempting, but wrong, to navigate the view
as follows:
</p>

<div class="org-src-container">
<pre class="src src-java"><span class="org-keyword">for</span> (<span class="org-type">EObject</span> <span class="org-function-name">o</span> : view.getVirtualContents()) {
  <span class="org-type">Component</span> <span class="org-variable-name">c</span> = (<span class="org-type">Component</span>) o;   <span class="org-comment-delimiter">// </span><span class="org-comment">this cast will fail</span>
  System.out.println(c.getName());
}
</pre>
</div>

<p>
This code will compile, but will raise a <code>ClassCastException</code> at runtime.  For
the same reasons, testing for instances with <code>instanceof</code> will not work with the
current version of EMF Views:
</p>

<div class="org-src-container">
<pre class="src src-java"><span class="org-keyword">for</span> (<span class="org-type">EObject</span> <span class="org-function-name">o</span> : view.getVirtualContents()) {
  <span class="org-keyword">if</span> (o <span class="org-keyword">instanceof</span> Component) {  <span class="org-comment-delimiter">// </span><span class="org-comment">this can never be true</span>
    ...
  }
}
</pre>
</div>

<p>
For testing instances, you have to use the reflective API.  But be careful about
using the metaclasses from <i>viewpoint</i> and not from the original <code>UMLPackage</code>.
The following is wrong:
</p>

<div class="org-src-container">
<pre class="src src-java"><span class="org-type">EClassifier</span> <span class="org-variable-name">comp</span> = UMLPackage.eINSTANCE.getComponent();
<span class="org-keyword">for</span> (<span class="org-type">EObject</span> <span class="org-function-name">o</span> : view.getVirtualContents()) {
  <span class="org-keyword">if</span> (comp.isInstance(o)) {      <span class="org-comment-delimiter">// </span><span class="org-comment">this test can still never be true</span>
    ...
  }
}
</pre>
</div>

<p>
The view conforms to the viewpoint, and elements of the viewpoint <i>refer</i> to
elements from <code>UMLPackage</code>, but they are not equal.  The correct way of finding
<code>Component</code> instances is by getting the <code>Component</code> metaclass from the virtual
<code>UMLPackage</code>:
</p>

<div class="org-src-container">
<pre class="src src-java"><span class="org-type">EPackage</span> <span class="org-variable-name">vUML</span> = viewpoint.getRootPackage().getESubpackages().get(0);
<span class="org-type">EClassifier</span> <span class="org-variable-name">comp</span> = vUML.getEClassifier(<span class="org-string">"Component"</span>);
<span class="org-keyword">for</span> (<span class="org-type">EObject</span> <span class="org-function-name">o</span> : view.getVirtualContents()) {
  <span class="org-keyword">if</span> (comp.isInstance(o)) {
    ...
  }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org2cce758" class="outline-4">
<h4 id="org2cce758">Creating a weaving model programmatically</h4>
<div class="outline-text-4" id="text-org2cce758">
<p>
We have seen how to create viewpoints and views programmatically, but only with
empty weaving models.  Let&rsquo;s recreate the publications and books view from the
other tutorials, but this time without creating any <code>eview</code>, <code>eviewpoint</code> or
<code>vpdl</code> file.
</p>

<p>
For simplicity, we&rsquo;ll assume the Book and Publication metamodels and models are
already loaded.
</p>

<div class="org-src-container">
<pre class="src src-java"><span class="org-type">EPackage</span> <span class="org-variable-name">Book</span> = ... <span class="org-comment-delimiter">// </span><span class="org-comment">load the Book.ecore metamodel</span>
EPackage Publ = ... <span class="org-comment-delimiter">// </span><span class="org-comment">load the Publication.ecore metamodel</span>

Resource book = ... <span class="org-comment-delimiter">// </span><span class="org-comment">load the book.xmi model</span>
Resource publ = ... <span class="org-comment-delimiter">// </span><span class="org-comment">load the publication.xmi model</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">1. Build the viewpoint weaving model</span>
VirtualLinksFactory f = VirtualLinksFactory.eINSTANCE;
<span class="org-type">WeavingModel</span> <span class="org-variable-name">WM1</span> = f.createWeavingModel();
WM1.setName(<span class="org-string">"publicationsAndBooks"</span>);

<span class="org-type">ConcreteConcept</span> <span class="org-variable-name">source</span>;
{
  <span class="org-type">ContributingModel</span> <span class="org-variable-name">cm</span> = f.createContributingModel();
  WM1.getContributingModels().add(cm);
  cm.setURI(<span class="org-string">"http://publication"</span>);
  <span class="org-type">ConcreteConcept</span> <span class="org-variable-name">cc</span> = f.createConcreteConcept();
  cm.getConcreteElements().add(cc);
  cc.setPath(<span class="org-string">"Publication"</span>);
  source = cc;
}

<span class="org-type">ConcreteConcept</span> <span class="org-variable-name">target</span>;
<span class="org-type">ConcreteElement</span> <span class="org-variable-name">nbPages</span>;
{
  <span class="org-type">ContributingModel</span> <span class="org-variable-name">cm</span> = f.createContributingModel();
  WM1.getContributingModels().add(cm);
  cm.setURI(<span class="org-string">"http://book"</span>);
  <span class="org-type">ConcreteConcept</span> <span class="org-variable-name">cc</span> = f.createConcreteConcept();
  cm.getConcreteElements().add(cc);
  cc.setPath(<span class="org-string">"Chapter"</span>);
  target = cc;
  <span class="org-type">ConcreteElement</span> <span class="org-variable-name">ce</span> = f.createConcreteElement();
  cm.getConcreteElements().add(ce);
  ce.setPath(<span class="org-string">"Chapter.nbPages"</span>);
  nbPages = ce;
}

{
  <span class="org-type">VirtualAssociation</span> <span class="org-variable-name">va</span> = f.createVirtualAssociation();
  WM1.getVirtualLinks().add(va);
  va.setName(<span class="org-string">"bookChapters"</span>);
  va.setUpperBound(-1);
  va.setSource(source);
  va.setTarget(target);
}

{
  <span class="org-type">Filter</span> <span class="org-variable-name">fi</span> = f.createFilter();
  WM1.getVirtualLinks().add(fi);
  fi.setName(<span class="org-string">"nbPages"</span>);
  fi.setTarget(nbPages);
}

<span class="org-comment-delimiter">// </span><span class="org-comment">2. Build the viewpoint</span>
<span class="org-type">Viewpoint</span> <span class="org-variable-name">viewpoint</span> = <span class="org-keyword">new</span> <span class="org-type">Viewpoint</span>(Arrays.asList(Book, Publ), WM1);

<span class="org-comment-delimiter">// </span><span class="org-comment">3. Build the view weaving model</span>
<span class="org-type">WeavingModel</span> <span class="org-variable-name">WM2</span> = f.createWeavingModel();
WM2.setName(<span class="org-string">"publicationsAndBooks"</span>);

{
  <span class="org-type">ContributingModel</span> <span class="org-variable-name">cm</span> = f.createContributingModel();
  WM2.getContributingModels().add(cm);
  cm.setURI(<span class="org-string">"http://publication"</span>);
  <span class="org-type">ConcreteConcept</span> <span class="org-variable-name">cc</span> = f.createConcreteConcept();
  cm.getConcreteElements().add(cc);
  <span class="org-type">EObject</span> <span class="org-variable-name">o</span> = publ.getContents().get(0);
  cc.setPath(publ.getURIFragment(o));
  source = cc;
}

{
  <span class="org-type">ContributingModel</span> <span class="org-variable-name">cm</span> = f.createContributingModel();
  WM2.getContributingModels().add(cm);
  cm.setURI(<span class="org-string">"http://book"</span>);
  <span class="org-type">ConcreteConcept</span> <span class="org-variable-name">cc</span> = f.createConcreteConcept();
  cm.getConcreteElements().add(cc);
  <span class="org-type">EObject</span> <span class="org-variable-name">o</span> = book.getContents().get(0).eContents().get(0);
  cc.setPath(book.getURIFragment(o));
  target = cc;
}

{
  <span class="org-type">VirtualAssociation</span> <span class="org-variable-name">va</span> = f.createVirtualAssociation();
  WM2.getVirtualLinks().add(va);
  va.setName(<span class="org-string">"bookChapters"</span>);
  va.setSource(source);
  va.setTarget(target);
}

<span class="org-comment-delimiter">// </span><span class="org-comment">4. Build the view</span>
<span class="org-type">View</span> <span class="org-variable-name">view</span> = <span class="org-keyword">new</span> <span class="org-type">View</span>(viewpoint, Arrays.asList(book, publ), WM2);

<span class="org-comment-delimiter">// </span><span class="org-comment">5. Navigate the new association in the view</span>
<span class="org-type">EObject</span> <span class="org-variable-name">vpubl</span> = view.getVirtualContents().get(1);
System.out.println(vpubl.eGet(vpubl.eClass().getEStructuralFeature(<span class="org-string">"title"</span>)));

<span class="org-type">EStructuralFeature</span> <span class="org-variable-name">assoc</span> = vpubl.eClass().getEStructuralFeature(<span class="org-string">"bookChapters"</span>);
<span class="org-type">EObject</span> <span class="org-variable-name">vchapter</span> = ((<span class="org-type">EList</span>&lt;<span class="org-type">EObject</span>&gt;) vpubl.eGet(assoc)).get(0);
System.out.println(
  vchapter.eGet(vchapter.eClass().getEStructuralFeature(<span class="org-string">"title"</span>)));
</pre>
</div>

<p>
As you can see, creating weaving model programmatically can be quite tedious,
but this is the option that gives you the most control.  In a real program, you
may want to create helper functions that take care of the boilerplate,
especially when building weaving models for views which can contain many
elements.  Here, thankfully, we just had to add one chapter to the virtual
association.
</p>

<p>
When executing this snippet, we get the following output:
</p>

<pre class="example">
ATL in Depth
Introduction to ATL
</pre>
</div>
</div>
</div>

<div id="outline-container-org3d75320" class="outline-3">
<h3 id="org3d75320">Querying a view with OCL</h3>
<div class="outline-text-3" id="text-org3d75320">
<p>
To query a view interactively, you can use the standard OCL console.  Refer to
the <a href="https://help.eclipse.org/oxygen/topic/org.eclipse.ocl.doc/help/InteractiveOCL.html">OCL documentation</a> on how to bring up the OCL console.  Once you have a
console open, you can query a view using OCL expressions:
</p>


<div class="figure">
<p><img src="images/ocl-query.png" alt="ocl-query.png">
</p>
</div>

<p>
In this figure, we see the <code>allChapters.eview</code> view open in the MoDisco Model
Browser, with the Xtext OCL console on the lower half.  When the <code>[Publication]
ATL in Depth</code> object is selected in MoDisco, it becomes the context object
(<code>self</code>) for the OCL console, as indicated by the text <code>Xtext OCL for
'Publication…'</code>.
</p>

<p>
In the console, we can see the results of executing the OCL query:
</p>

<pre class="example">
self.bookChapters-&gt;collect(c | c.title)
</pre>

<p>
which collects the titles of all the chapters in this publication in an set,
using the <code>bookChapters</code> virtual association.
</p>
</div>

<div id="outline-container-org0926820" class="outline-4">
<h4 id="org0926820">Programmatic OCL queries</h4>
<div class="outline-text-4" id="text-org0926820">
<p>
You can also use OCL programmatically.  Here is an example of code using the OCL
Pivot API which the run the same query as above:
</p>

<div class="org-src-container">
<pre class="src src-java"><span class="org-comment-delimiter">// </span><span class="org-comment">Initialize EMF</span>
<span class="org-type">Map</span>&lt;<span class="org-type">String</span>, <span class="org-type">Object</span>&gt; <span class="org-variable-name">map</span> = <span class="org-constant">Resource</span>.<span class="org-constant">Factory</span>.<span class="org-constant">Registry</span>.INSTANCE
  .getExtensionToFactoryMap();
map.put(<span class="org-string">"xmi"</span>, <span class="org-keyword">new</span> <span class="org-type">XMIResourceFactoryImpl</span>());
map.put(<span class="org-string">"ecore"</span>, <span class="org-keyword">new</span> <span class="org-type">EcoreResourceFactoryImpl</span>());
map.put(<span class="org-string">"eview"</span>, <span class="org-keyword">new</span> <span class="org-type">EmfViewsFactory</span>());

<span class="org-comment-delimiter">// </span><span class="org-comment">Make sure the weaving model package is loaded</span>
VirtualLinksPackage.eINSTANCE.eClass();

<span class="org-comment-delimiter">// </span><span class="org-comment">Register EclDelegate as handler for ".ecl" weaving models</span>
VirtualLinksDelegator.register(<span class="org-string">"ecl"</span>, <span class="org-keyword">new</span> <span class="org-type">EclDelegate</span>());

<span class="org-comment-delimiter">// </span><span class="org-comment">Initialize OCL</span>
<span class="org-type">OCL</span> <span class="org-variable-name">ocl</span> = OCL.newInstance(<span class="org-constant">EcoreEnvironmentFactory</span>.INSTANCE);
<span class="org-type">OCLHelper</span> <span class="org-variable-name">oclHelper</span> = ocl.createOCLHelper();

<span class="org-comment-delimiter">// </span><span class="org-comment">Load the view</span>
<span class="org-type">Resource</span> <span class="org-variable-name">view</span>  = <span class="org-keyword">new</span> <span class="org-type">ResourceSetImpl</span>()
  .getResource(URI.createURI(<span class="org-string">"allChapters.eview"</span>), <span class="org-constant">true</span>);
view.load(<span class="org-constant">null</span>);

<span class="org-comment-delimiter">// </span><span class="org-comment">Set the query context</span>
<span class="org-type">EObject</span> <span class="org-variable-name">root</span> = view.getContents().get(0);
<span class="org-type">EObject</span> <span class="org-variable-name">context</span> = root.eClass();
oclHelper.setContext(context);

<span class="org-comment-delimiter">// </span><span class="org-comment">Create the query</span>
<span class="org-type">Query</span> <span class="org-variable-name">query</span> = ocl.createQuery(
  oclHelper.createQuery(<span class="org-string">"self.bookChapters-&gt;collect(c | c.title)"</span>));

<span class="org-comment-delimiter">// </span><span class="org-comment">Evaluate and print result</span>
System.out.println(<span class="org-string">"Result: "</span> + query.evaluate(root));
</pre>
</div>

<p>
Running that program yields:
</p>

<pre class="example">
Result: [Introduction to ATL,
         An Example Transformation,
         A Couple of Compilers,
         ATL Harder]
</pre>
</div>
</div>
</div>

<div id="outline-container-org8489b14" class="outline-3">
<h3 id="org8489b14">Transforming a view with ATL</h3>
<div class="outline-text-3" id="text-org8489b14">
<div class="note">
<p>
This tutorial still needs to be written.  Come back later!
</p>

</div>
</div>
</div>
</div>

<div id="outline-container-org911f998" class="outline-2">
<h2 id="org911f998">Concepts</h2>
<div class="outline-text-2" id="text-org911f998">
</div>
<div id="outline-container-org1ca3f19" class="outline-3">
<h3 id="org1ca3f19">Views</h3>
<div class="outline-text-3" id="text-org1ca3f19">
<p>
In EMF Views, views are lightweight (virtual) models that can rely on one or
several contributing models.  Thus, they allow you to access their contributing
models transparently.
</p>

<p>
There are three ways to create a view:
</p>

<ol class="org-ol">
<li>By writing an <a href="#org6853c8a"><code>eview</code> (and an <code>eviewpoint</code>) file</a>.</li>
<li>By writing a <a href="#org6cc3124">VPDL file</a>.</li>
<li>By using the EMF Views <a href="#orge295c2f">API</a>.</li>
</ol>

<p>
The <code>VPDL</code> method is the fastest for interactive creation, but the <code>eview</code>
approach is more flexible.  Using the API should be preferred when creating
views from Java code.
</p>
</div>

<div id="outline-container-org6853c8a" class="outline-4">
<h4 id="org6853c8a">eview and eviewpoint files</h4>
<div class="outline-text-4" id="text-org6853c8a">
<p>
The <code>eview</code> and <code>eviewpoint</code> files respectively describe views and viewpoints.
</p>

<p>
In Eclipse, the EMF Views plugin installs parsers for these file extensions
through the <code>org.eclipse.emf.ecore.extension_parser</code> extension point. This means
you are able to open <code>eview</code> and <code>eviewpoint</code> files in standard EMF model
editors such as the Sample Ecore Model Editor, or the <a href="https://help.eclipse.org/oxygen/topic/org.eclipse.modisco.infrastructure.doc/mediawiki/model_browser/user.html">MoDisco Model Browser</a>.
</p>

<p>
The syntax of these files follows the text encoding of <code>java.util.Properties</code>.
That is, the file is a list of properties as <code>KEY=VALUE</code> pairs, where both <code>KEY</code>
and <code>VALUE</code> are strings:
</p>

<div class="org-src-container">
<pre class="src src-sh"><span class="org-variable-name">key1</span>=thisisavalue
<span class="org-comment-delimiter"># </span><span class="org-comment">a pound begins a line comment</span>
<span class="org-variable-name">key2</span>=everything to the right of the equals is a value
<span class="org-comment-delimiter"># </span><span class="org-comment">Values can span multiple lines by escaping newlines with a backslash</span>
<span class="org-variable-name">key3</span>=value spanning<span class="org-sh-escaped-newline">\</span>
     multiple lines
</pre>
</div>

<p>
For <code>eviewpoint</code> files, there are only two valid properties:
</p>

<dl class="org-dl">
<dt><code>contributingMetamodels</code></dt><dd>Comma-separated list of URIs to contributing
metamodels.  This key is mandatory.</dd>

<dt><code>weavingModel</code></dt><dd>URI for the viewpoint&rsquo;s <a href="#org87f9f05">weaving model</a>.  This key is
optional; if unspecified, the viewpoint will be constructed with an empty
weaving model.</dd>
</dl>

<p>
URIs are built using <code>org.eclipse.emf.common.util.URI.createURI</code>.  This allows
you to specify files using the <code>file</code> or <code>platform</code> schemes.  Without an
explicit scheme, the file one is used by default.  Note that relative file paths
are resolved relatively to the location of the <code>eviewpoint</code> file.
</p>

<p>
For metamodels, you can specify either the location of an <code>ecore</code> file with the
above schemes, or if the URI begins with <code>http://</code> it is taken to be the
namespace URI of the <code>EPackage</code> and is looked up in the Ecore package registry.
</p>

<p>
Here is an example of a valid <code>eviewpoint</code> file:
</p>

<pre class="example">
contributingMetamodels=../metamodels/Book.ecore,\
                       http://www.eclipse.org/uml2/5.0.0/UML
weavingModel=books-and-uml.xmi
</pre>

<p>
Here the <code>Book.ecore</code> metamodel is loaded through a relative file URI, and the
UML metamodel through its namespace URI.
</p>

<p>
<code>eview</code> files have 4 valid properties:
</p>

<dl class="org-dl">
<dt><code>viewpoint</code></dt><dd>URI to the <code>eviewpoint</code> file.  This key is mandatory.</dd>
<dt><code>contributingModels</code></dt><dd>Comma-separated list of URIs to contributing models.
This key is mandatory.</dd>
<dt><code>weavingModel</code></dt><dd>URI to the view&rsquo;s <a href="#org87f9f05">weaving model</a>.  This key conflicts with
<code>matchingModel</code>.</dd>
<dt><code>matchingModel</code></dt><dd>URI to a supported <a href="#org2dde80d">matching model</a>.  This key conflicts with
<code>weavingModel</code>.</dd>
</dl>

<p>
Since the purpose of the matching model is to create the weaving model used by
the view, you must give exactly one of the keys { <code>matchingModel</code>,
<code>weavingModel</code> }.
</p>

<p>
All file URIs are resolved relatively to the <code>eview</code> file&rsquo;s location.
</p>

<p>
Here is an example of a valid <code>eview</code> file:
</p>

<pre class="example">
viewpoint=../viewpoints/booksAndPub.eviewpoint
contributingModels=models/book.xmi,../../publication.xmi
matchingModel=booksAndPub.ecl
</pre>

<p>
For a step-by-step guide on creating views with <code>eview</code> files, see <a href="#org3683e2a">Creating a
view manually</a>.
</p>
</div>
</div>

<div id="outline-container-org6cc3124" class="outline-4">
<h4 id="org6cc3124">VPDL</h4>
<div class="outline-text-4" id="text-org6cc3124">
<p>
VPDL, standing for <i>ViewPoint Description Language</i>, is a domain-specific
language for easing the creation of views and viewpoints when using EMF Views.
The syntax of VPDL is inspired by the syntax of the SQL&rsquo;s <code>SELECT</code> statement.
</p>

<div class="note">
<p>
VPDL is still under development and its syntax is likely to evolve in the future.
</p>

</div>

<p>
This is an overview of the structure of a VPDL file:
</p>

<div class="org-src-container">
<pre class="src src-vpdl"><span class="org-keyword">create</span> <span class="org-keyword">view</span> <span class="org-comment-delimiter">/* </span><span class="org-comment">view-name */</span> <span class="org-keyword">as</span>

<span class="org-keyword">select</span> <span class="org-comment-delimiter">// </span><span class="org-comment">features and new associations</span>

<span class="org-keyword">from</span> <span class="org-comment-delimiter">// </span><span class="org-comment">contributing metamodels</span>

<span class="org-keyword">where</span> <span class="org-comment-delimiter">// </span><span class="org-comment">ECL matching rules for new associations</span>
</pre>
</div>

<p>
There are three clauses:
</p>

<dl class="org-dl">
<dt><code>select</code></dt><dd><p>
Specifies which contributing metamodel features to include in the
view, and which new associations (if any) to create between models.
</p>

<p>
To select a feature, you write its dot-separated path:
</p>

<div class="verbatim">
<p>
<i>metamodel</i> . <i>class</i> . <i>feature</i>
</p>

</div>

<p>
where <i>metamodel</i> is the alias given to the metamodel in the <code>from</code> clause.
E.g., <code>uml.Component.name</code> will include the <code>name</code> feature of the
<code>Component</code> class in the metamodel called <code>uml</code>.
</p>

<p>
You can select multiple features from the same class by using square
brackets: <code>uml.Component[name, role]</code> is equivalent to:
</p>

<pre class="example">
uml.Component.name,
uml.Component.role
</pre>

<p>
Lastly, you can include all features of a class using a wildcard:
<code>uml.Component.*</code>.
</p>

<p>
You create new associations between two classes with a <code>join</code> statement:
</p>

<div class="verbatim">
<p>
<i>metamodel</i> . <i>class1</i> join <i>metamodel</i> . <i>class2</i> as <i>name</i>
</p>

</div>

<p>
This will add a virtual association feature named <code>name</code> in <code>class1</code> with
type <code>class2</code>.  Note that this does not specify <i>how</i> the association will
be populated based on model contents.  For that, you have to use the
<code>where</code> clause.
</p>

<p>
The <code>select</code> clause is mandatory.  At the very least, you must include one
feature (otherwise the view will be empty and you could use an empty
weaving model directly instead of writing a VPDL file).
</p></dd>

<dt><code>from</code></dt><dd><p>
Specifies the metamodels contributing to the viewpoint.
</p>

<div class="verbatim">
<p>
<i>namespace-uri</i> as <i>alias</i>
</p>

</div>

<p>
The metamodels are given through their namespace URIs, and an alias must be
given and used in the <code>select</code> clause.
</p>

<p>
This clause is mandatory.
</p></dd>

<dt><code>where</code></dt><dd><p>
Specifies the rules used for populating new associations by
matching model elements.
</p>

<p>
The rules are given as strings containing ECL expressions, where the names
<code>s</code> and <code>t</code> are bound respectively to the source model and target model of
the association.
</p>

<p>
This clause is optional.
</p></dd>
</dl>

<p>
Here is an example of a VPDL file:
</p>

<div class="org-src-container">
<pre class="src src-vpdl"><span class="org-keyword">create</span> <span class="org-keyword">view</span> threeModelComposition <span class="org-keyword">as</span>

<span class="org-keyword">select</span>
    togaf.Requirement <span class="org-keyword">join</span> reqif.SpecObject <span class="org-keyword">as</span> detailedRequirement,
    togaf.Process <span class="org-keyword">join</span> bpmn.Process <span class="org-keyword">as</span> detailedProcess,

    togaf.Process.isAutomated,
    togaf.Requirement[statementOfRequirement, acceptanceCriteria],
    reqif.SpecObject.type,
    bpmn.Process[isClosed, isExecutable, processType],

    togaf.Element.name,
    togaf.EnterpriseArchitecture.architectures,
    togaf.StrategicArchitecture.strategicElements,
    togaf.BusinessArchitecture.processes,

    reqif.ReqIFContent.specObjects,
    reqif.ReqIF.coreContent,
    reqif.Identifiable[desc, longName],

    bpmn.Definitions[name, rootElements],
    bpmn.CallableElement.name,

<span class="org-keyword">from</span>
  <span class="org-string">'http://www.obeonetwork.org/dsl/togaf/contentfwk/9.0.0'</span> <span class="org-keyword">as</span> togaf,
  <span class="org-string">'http://www.omg.org/spec/BPMN/20100524/MODEL-XMI'</span>       <span class="org-keyword">as</span> bpmn,
  <span class="org-string">'http://www.omg.org/spec/ReqIF/20110401/reqif.xsd'</span>      <span class="org-keyword">as</span> reqif,

<span class="org-keyword">where</span> <span class="org-string">'s.name=t.name and s.isAutomated = false'</span> <span class="org-keyword">for</span> detailedProcess,
      <span class="org-string">'t.values.exists(v | v.theValue=s.name)'</span>  <span class="org-keyword">for</span> detailedRequirement,
</pre>
</div>

<p>
The following diagram outlines the VPDL grammar; <a class="external" href="https://raw.githubusercontent.com/atlanmod/emfviews/master/dsls/vpdl/org.atlanmod.emfviews.vpdl/src/org/atlanmod/emfviews/vpdl/Vpdl.xtext" target="_new">the full Xtext grammar</a> can be
found in the source code.
</p>


<div class="figure">
<p><img src="images/vpdl-grammar.svg" class="no-shadow"/>
</p>
</div>


<p>
The tutorial <a href="#orgc0e03cf">Creating a view with VPDL</a> takes you through creating a VPDL file
and using it in Eclipse.
</p>
</div>
</div>

<div id="outline-container-orge295c2f" class="outline-4">
<h4 id="orge295c2f">Java API</h4>
<div class="outline-text-4" id="text-orge295c2f">
<p>
You can construct <code>View</code> and <code>Viewpoint</code> classes directly by invoking their
constructors:
</p>

<div class="org-src-container">
<pre class="src src-java">Viewpoint(<span class="org-type">List</span>&lt;<span class="org-type">EPackage</span>&gt; <span class="org-variable-name">metamodels</span>)
Viewpoint(<span class="org-type">List</span>&lt;<span class="org-type">EPackage</span>&gt; <span class="org-variable-name">metamodels</span>, <span class="org-type">WeavingModel</span> <span class="org-variable-name">wm</span>)

View(<span class="org-type">Viewpoint</span> <span class="org-variable-name">v</span>, <span class="org-type">List</span>&lt;<span class="org-type">Resource</span>&gt; <span class="org-variable-name">models</span>)
View(<span class="org-type">Viewpoint</span> <span class="org-variable-name">v</span>, <span class="org-type">List</span>&lt;<span class="org-type">Resource</span>&gt; <span class="org-variable-name">models</span>, <span class="org-type">WeavingModel</span> <span class="org-variable-name">wm</span>)
</pre>
</div>

<p>
If the weaving model argument is not specified, an empty weaving model is used
instead (see <code>Viewpoint.emptyWeavingModel</code>).
</p>

<p>
You can browse the content of the viewpoint using <code>Viewpoint.getRootPackage</code>,
and the content of the view using <code>View.getVirtualContents</code>.
</p>

<p>
Finally, you may also associate these objects to resources, should you want to
serialize them into files:
</p>

<div class="org-src-container">
<pre class="src src-java"><span class="org-type">ViewpointResource</span> <span class="org-variable-name">vpr</span> = <span class="org-keyword">new</span> <span class="org-type">ViewpointResource</span>(<span class="org-string">"my.eviewpoint"</span>);
vpr.setResource(viewpoint);
vpr.save(<span class="org-constant">null</span>);

<span class="org-type">ViewResource</span> <span class="org-variable-name">vr</span> = <span class="org-keyword">new</span> <span class="org-type">ViewResource</span>(<span class="org-string">"my.eview"</span>);
viewResource.setView(view);
viewResource.save(<span class="org-constant">null</span>);
</pre>
</div>

<p>
This will save the viewpoint and views to their corresponding files.
</p>

<p>
See <a href="#org2d36e57">Creating a view programmatically</a> for a guided example on how to use the API.
</p>
</div>
</div>
</div>

<div id="outline-container-org87f9f05" class="outline-3">
<h3 id="org87f9f05">Weaving models</h3>
<div class="outline-text-3" id="text-org87f9f05">
<p>
Weaving models describe what elements are put into viewpoints and views.  The
following gives the metamodel of weaving models as a class diagram:
</p>


<div class="figure">
<p><img src="images/weavingmodel-metamodel.svg" class="no-shadow"/>
</p>
</div>

<p>
We following subsections describe the role of each element.  Note that, as
weaving models can be used at the metamodel and model levels for building
viewpoints and views (respectively), the following description applies to both
levels, even though we only use the terms &ldquo;models&rdquo; and &ldquo;views&rdquo;.  For elements
that are handled differently by viewpoints and views, we make the distinction
explicit.
</p>
</div>

<div id="outline-container-org818057d" class="outline-4">
<h4 id="org818057d">Weaving model</h4>
<div class="outline-text-4" id="text-org818057d">
<p>
The <code>WeavingModel</code> is the root model element.
</p>

<p>
It contains the contributing models and the virtual links, which are
modifications made to the models that only appear in the view.
</p>

<p>
Its <code>name</code> attribute is used as part of the viewpoint&rsquo;s namespace URI.  Views do
not make use of the <code>name</code> attribute.
</p>

<p>
The <code>whitelist</code> flag changes the meaning of the filters.  If the <code>whitelist</code>
flag is false (the default), then the view will include all the elements of
contributing models, unless they are explicitly filtered out.  If the
<code>whitelist</code> flag is true, then the view will include no element, unless they are
explicitly filtered in.
</p>
</div>
</div>

<div id="outline-container-org37100a1" class="outline-4">
<h4 id="org37100a1">Contributing model</h4>
<div class="outline-text-4" id="text-org37100a1">
<p>
A <code>ContributingModel</code> is a model included in the view.
</p>

<p>
The purpose of this class is to hold the concrete elements that are
targeted by virtual links.
</p>

<p>
<code>URI</code> always refers to the metamodel namespace URI, both for viewpoint and
view weaving models.
</p>
</div>
</div>

<div id="outline-container-orge9b9f0b" class="outline-4">
<h4 id="orge9b9f0b">Concrete element</h4>
<div class="outline-text-4" id="text-orge9b9f0b">
<p>
A <code>ConcreteElement</code> is an element of a contributing model.
</p>

<p>
For viewpoints, <code>path</code> is the fully qualified name to the element (not including
the metamodel name, since that&rsquo;s already given by its container
<code>ContributingModel</code>).  E.g., <code>Component.name</code> would point to the <code>name</code>
attribute of the <code>Component</code> class in a given metamodel.
</p>

<p>
For views, <code>path</code> is the URI returned by <code>Resource.getURIFragment</code>.
</p>

<p>
A concrete element can further be of two subtypes: <code>ConcreteConcept</code> and
<code>ConcreteAssociation</code>.  This distinction is useful for virtual links other than
filters, where for example the opposite to a virtual associations can only be an
association, not just any element.
</p>
</div>
</div>

<div id="outline-container-orgabeda4e" class="outline-4">
<h4 id="orgabeda4e">Virtual link</h4>
<div class="outline-text-4" id="text-orgabeda4e">
<p>
<code>VirtualLink</code> is the parent class for all modifications made to the model.
</p>

<p>
All modifications have a name, which is used for the virtual feature name,
except for the <code>Filter</code> class where the name is ignored.
</p>
</div>
</div>

<div id="outline-container-org64e626d" class="outline-4">
<h4 id="org64e626d">Filter</h4>
<div class="outline-text-4" id="text-org64e626d">
<p>
A <code>Filter</code>, depending on the value of <code>WeavingModel.whitelist</code>, includes or
excludes an element from the contributing models.
</p>

<p>
It can only refer to <code>ConcreteElements</code>.
</p>
</div>
</div>

<div id="outline-container-org6fd68a2" class="outline-4">
<h4 id="org6fd68a2">Virtual association</h4>
<div class="outline-text-4" id="text-org6fd68a2">
<p>
A <code>VirtualAssociation</code> is an association that exists only in the view.
</p>

<p>
It has <code>source</code> and a <code>target</code>, which can be concrete or virtual concepts.
Thus, you may create a virtual association between one class of a contributing
metamodel and a virtual class that only exists in the view.
</p>

<p>
The <code>lowerBound</code> and <code>upperBound</code> properties determine the cardinality of the
association, just like in Ecore metamodels.  If the <code>composition</code> flag is true,
the virtual association is a containment.  A virtual association can have one
opposite association (virtual or not), given by the <code>opposite</code> reference.
</p>
</div>
</div>

<div id="outline-container-org25bd3e7" class="outline-4">
<h4 id="org25bd3e7">Virtual concept</h4>
<div class="outline-text-4" id="text-org25bd3e7">
<p>
A <code>VirtualConcept</code> is a concept that exists only in the view.
</p>

<p>
It can subclass or superclass other concepts (virtual or not).
</p>
</div>
</div>

<div id="outline-container-org4b2600d" class="outline-4">
<h4 id="org4b2600d">Virtual property</h4>
<div class="outline-text-4" id="text-org4b2600d">
<p>
A <code>VirtualProperty</code> is a property that exists only in the view.
</p>

<p>
It must attach to a <code>parent</code> concept (virtual or not).  The <code>optional</code> flag
determines its cardinality (1 if <code>false</code> and <code>0..1</code> if true).  The <code>type</code>
attribute describes the primitive type of the property.  The following types are
supported:
</p>

<pre class="example">
boolean
byte
char
double
float
int
long
short
Date
String
</pre>
</div>
</div>
</div>

<div id="outline-container-org2dde80d" class="outline-3">
<h3 id="org2dde80d">Matching models</h3>
<div class="outline-text-3" id="text-org2dde80d">
<p>
A matching model is a more declarative way to create a weaving model for views.
Its main purpose is to populate virtual associations based on the content of
the contributing models.
</p>

<p>
In the current implementation, EMF Views can use ECL files to create weaving
models.  Such files typically contain one rule for each virtual association.
Here is one ECL file with two rules:
</p>

<div class="org-src-container">
<pre class="src src-ecl"><span class="org-comment-delimiter">//</span><span class="org-comment">alias_ea=http://www.obeonetwork.org/dsl/togaf/contentfwk/9.0.0</span>
<span class="org-comment-delimiter">//</span><span class="org-comment">alias_bpmn=http://www.omg.org/spec/BPMN/20100524/MODEL-XMI</span>
<span class="org-comment-delimiter">//</span><span class="org-comment">alias_reqif=http://www.omg.org/spec/ReqIF/20110401/reqif.xsd</span>

<span class="org-keyword">rule</span> detailedProcess
<span class="org-keyword">match</span> s : ea!Process
<span class="org-keyword">with</span>  t : bpmn!Process
{
  <span class="org-keyword">compare</span>
  {
    <span class="org-keyword">return</span> s.name = t.name;
  }
}

<span class="org-keyword">rule</span> detailedRequirement
<span class="org-keyword">match</span> s : ea!Requirement
<span class="org-keyword">with</span>  t : reqif!SpecObject
{
  <span class="org-keyword">compare</span>
  {
    <span class="org-keyword">return</span> t.values.exists(v | v.theValue = <span class="org-string">"s.name"</span>);
  }
}
</pre>
</div>
</div>

<div id="outline-container-org20f4228" class="outline-4">
<h4 id="org20f4228">Adding new matching models</h4>
<div class="outline-text-4" id="text-org20f4228">
<p>
You can add new matching engines through the
<code>org.atlanmod.emfviews.virtuallinks.delegator</code> extension point.  It takes a file
extension (e.g., &ldquo;ecl&rdquo;) and a class implementing the <code>IVirtualLinksDelegate</code>
interface, which has a single method:
</p>

<div class="org-src-container">
<pre class="src src-java"><span class="org-type">WeavingModel</span> <span class="org-function-name">createWeavingModel</span>(<span class="org-type">URI</span> <span class="org-variable-name">linksDslFile</span>,
                                <span class="org-type">List</span>&lt;<span class="org-type">Resource</span>&gt; <span class="org-variable-name">inputModels</span>)
</pre>
</div>

<p>
You can look at <a class="external" href="https://github.com/atlanmod/emfviews/blob/master/plugins/org.atlanmod.emfviews.virtuallinksepsilondelegate/src/org/atlanmod/emfviews/virtuallinksepsilondelegate/EclDelegate.java" target="_new"><code>EclDelegate</code></a> for an example implementation of this interface.
</p>
</div>
</div>
</div>
</div>
</div>
</body>
</html>
